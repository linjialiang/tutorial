<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>预处理器（Preprocessor） - C 语言教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="预处理器（Preprocessor）"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/clang-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/clang-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;C 语言教程</a></li><li class="is-active"><a class="has-text-grey" href="preprocessor.html">预处理器</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="enum.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Enum 类型</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="io.html">I/O 函数 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">预处理器（Preprocessor）</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p>C 语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。</p><p>预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，执行<code>#</code>开头的预处理指令。本章介绍 C 语言的预处理指令。</p><p>预处理指令可以出现在程序的任何地方，但是习惯上，往往放在代码的开头部分。</p><p>每个预处理指令都以<code>#</code>开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。<code>#</code>和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。</p><p>所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。</p><h2 id="define">#define <a class="markdownIt-Anchor" href="#define">#</a></h2><p><code>#define</code>是最常见的预处理指令，用来将指定的词替换成另一个词。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100</span>
</code></pre><p>上面示例中，<code>#define</code>指定将源码里面的<code>MAX</code>，全部替换成<code>100</code>。<code>MAX</code>就称为一个宏。</p><p>宏的名称不允许有空格，而且必须遵守 C 语言的变量命名规则，只能使用字母、数字与下划线（<code>_</code>），且首字符不能是数字。</p><p>宏是原样替换，指定什么内容，就一模一样替换成什么内容。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELLO <span class="hljs-string">&quot;Hello, world&quot;</span></span>

<span class="hljs-comment">// 相当于 printf(&quot;%s&quot;, &quot;Hello, world&quot;);</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, HELLO);
</code></pre><p>上面示例中，宏<code>HELLO</code>会被原样替换成<code>&quot;Hello, world&quot;</code>。</p><p><code>#define</code>指令可以出现在源码文件的任何地方，从指令出现的地方到文件末尾都有效。习惯上，会将<code>#define</code>放在源码文件的头部。它的主要好处是，会使得程序的可读性更好，也更容易修改。</p><p><code>#define</code>指令从<code>#</code>开始，一直到换行符为止。如果整条指令过长，可以在折行处使用反斜杠，延续到下一行。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> OW <span class="hljs-string">&quot;C programming language is invented \
in 1970s.&quot;</span></span>
</code></pre><p>上面示例中，第一行结尾的反斜杠将<code>#define</code>指令拆成两行。</p><p><code>#define</code>允许多重替换，即一个宏可以包含另一个宏。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO 2</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FOUR TWO*TWO</span>
</code></pre><p>上面示例中，<code>FOUR</code>会被替换成<code>2*2</code>。</p><p>注意，如果宏出现在字符串里面（即出现在双引号中），或者是其他标识符的一部分，就会失效，并不会发生替换。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> TWO 2</span>

<span class="hljs-comment">// 输出 TWO</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;TWO\n&quot;</span>);

<span class="hljs-comment">// 输出 22</span>
<span class="hljs-type">const</span> TWOs = <span class="hljs-number">22</span>;
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, TWOs);
</code></pre><p>上面示例中，双引号里面的<code>TWO</code>，以及标识符<code>TWOs</code>，都不会被替换。</p><p>同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。</p><pre class="hljs"><code><span class="hljs-comment">// 正确</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO hello</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO hello</span>

<span class="hljs-comment">// 报错</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR hello</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> BAR world</span>
</code></pre><p>上面示例中，宏<code>FOO</code>没有变化，所以可以重复定义，宏<code>BAR</code>发生了变化，就报错了。</p><h2 id="带参数的宏">带参数的宏 <a class="markdownIt-Anchor" href="#带参数的宏">#</a></h2><h3 id="基本用法">基本用法 <a class="markdownIt-Anchor" href="#基本用法">#</a></h3><p>宏的强大之处在于，它的名称后面可以使用括号，指定接受一个或多个参数。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(X) X*X</span>
</code></pre><p>上面示例中，宏<code>SQUARE</code>可以接受一个参数<code>X</code>，替换成<code>X*X</code>。</p><p>注意，宏的名称与左边圆括号之间，不能有空格。</p><p>这个宏的用法如下。</p><pre class="hljs"><code><span class="hljs-comment">// 替换成 z = 2*2;</span>
z = SQUARE(<span class="hljs-number">2</span>);
</code></pre><p>这种写法很像函数，但又不是函数，而是完全原样的替换，会跟函数有不一样的行为。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(X) X*X</span>

<span class="hljs-comment">// 输出19</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, SQUARE(<span class="hljs-number">3</span> + <span class="hljs-number">4</span>));
</code></pre><p>上面示例中，<code>SQUARE(3 + 4)</code>如果是函数，输出的应该是49（<code>7*7</code>）；宏是原样替换，所以替换成<code>3 + 4*3 + 4</code>，最后输出19。</p><p>可以看到，原样替换可能导致意料之外的行为。解决办法就是在定义宏的时候，尽量多使用圆括号，这样可以避免很多意外。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> SQUARE(X) ((X) * (X))</span>
</code></pre><p>上面示例中，<code>SQUARE(X)</code>替换后的形式，有两层圆括号，就可以避免很多错误的发生。</p><p>宏的参数也可以是空的。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() getc(stdin)</span>
</code></pre><p>上面示例中，宏<code>getchar()</code>的参数就是空的。这种情况其实可以省略圆括号，但是加上了，会让它看上去更像函数。</p><p>一般来说，带参数的宏都是一行的。下面是两个例子。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(x, y) ((x)&gt;(y)?(x):(y))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> IS_EVEN(n) ((n)%2==0)</span>
</code></pre><p>如果宏的长度过长，可以使用反斜杠（<code>\</code>）折行，将宏写成多行。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRINT_NUMS_TO_PRODUCT(a, b) { \
  int product = (a) * (b); \
  for (int i = 0; i &lt; product; i++) { \
    printf(<span class="hljs-string">&quot;%d\n&quot;</span>, i); \
  } \
}</span>
</code></pre><p>上面示例中，替换文本放在大括号里面，这是为了创造一个块作用域，避免宏内部的变量污染外部。</p><p>带参数的宏也可以嵌套，一个宏里面包含另一个宏。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUADP(a, b, c) ((-(b) + sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> QUADM(a, b, c) ((-(b) - sqrt((b) * (b) - 4 * (a) * (c))) / (2 * (a)))</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> QUAD(a, b, c) QUADP(a, b, c), QUADM(a, b, c)</span>
</code></pre><p>上面示例是一元二次方程组求解的宏，由于存在正负两个解，所以宏<code>QUAD</code>先替换成另外两个宏<code>QUADP</code>和<code>QUADM</code>，后者再各自替换成一个解。</p><p>那么，什么时候使用带参数的宏，什么时候使用函数呢？</p><p>一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候会产生意想不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。</p><p>宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算，为了读懂前人的代码，需要对它有所了解。</p><h3 id="运算符运算符"><code>#</code>运算符，<code>##</code>运算符 <a class="markdownIt-Anchor" href="#运算符运算符">#</a></h3><p>由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上<code>#</code>。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> STR(x) #x</span>

<span class="hljs-comment">// 等同于 printf(&quot;%s\n&quot;, &quot;3.14159&quot;);</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, STR(<span class="hljs-number">3.14159</span>));
</code></pre><p>上面示例中，<code>STR(3.14159)</code>会被替换成<code>3.14159</code>。如果<code>x</code>前面没有<code>#</code>，这会被解释成一个浮点数，有了<code>#</code>以后，就会被转换成字符串。</p><p>下面是另一个例子。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> XNAME(n) <span class="hljs-string">&quot;x&quot;</span>#n</span>

<span class="hljs-comment">// 输出 x4</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, XNAME(<span class="hljs-number">4</span>));
</code></pre><p>上面示例中，<code>#n</code>指定参数输出为字符串，再跟前面的字符串结合，最终输出为<code>&quot;x4&quot;</code>。如果不加<code>#</code>，这里实现起来就很麻烦了。</p><p>如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的标识符，可以使用<code>##</code>运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> MK_ID(n) i##n</span>
</code></pre><p>上面示例中，<code>n</code>是宏<code>MK_ID</code>的参数，这个参数需要跟标识符<code>i</code>粘合在一起，这时<code>i</code>和<code>n</code>之间就要使用<code>##</code>运算符。下面是这个宏的用法示例。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span>, <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>, <span class="hljs-title function_">MK_ID</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;
<span class="hljs-comment">// 替换成</span>
<span class="hljs-type">int</span> i1, i2, i3;
</code></pre><p>上面示例中，替换后的文本<code>i1</code>、<code>i2</code>、<code>i3</code>是三个标识符，参数<code>n</code>是标识符的一部分。从这个例子可以看到，<code>##</code>运算符的一个主要用途是批量生成变量名和标识符。</p><h3 id="不定参数的宏">不定参数的宏 <a class="markdownIt-Anchor" href="#不定参数的宏">#</a></h3><p>宏的参数还可以是不定数量的（即不确定有多少个参数），<code>...</code>表示剩余的参数。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__</span>
</code></pre><p>上面示例中，<code>X(a, b, ...)</code>表示<code>X()</code>至少有两个参数，多余的参数使用<code>...</code>表示。在替换文本中，<code>__VA_ARGS__</code>代表多余的参数（每个参数之间使用逗号分隔）。下面是用法示例。</p><pre class="hljs"><code>X(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hi!&quot;</span>, <span class="hljs-number">12</span>)
<span class="hljs-comment">// 替换成</span>
(<span class="hljs-number">10</span>*(<span class="hljs-number">5</span>) + <span class="hljs-number">20</span>*(<span class="hljs-number">4</span>)), <span class="hljs-number">3.14</span>, <span class="hljs-string">&quot;Hi!&quot;</span>, <span class="hljs-number">12</span>
</code></pre><p>注意，<code>...</code>只能替代宏的尾部参数，不能写成下面这样。</p><pre class="hljs"><code><span class="hljs-comment">// 报错</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> WRONG(X, ..., Y) #X #__VA_ARGS__ #Y</span>
</code></pre><p>上面示例中，<code>...</code>替代中间部分的参数，这是不允许的，会报错。</p><p><code>__VA_ARGS__</code>前面加上一个<code>#</code>号，可以让输出变成一个字符串。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> X(...) #__VA_ARGS__</span>

<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, X(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));  <span class="hljs-comment">// Prints &quot;1, 2, 3&quot;</span>
</code></pre><h2 id="undef">#undef <a class="markdownIt-Anchor" href="#undef">#</a></h2><p><code>#undef</code>指令用来取消已经使用<code>#define</code>定义的宏。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIMIT 400</span>
<span class="hljs-meta">#<span class="hljs-keyword">undef</span> LIMIT</span>
</code></pre><p>上面示例的<code>undef</code>指令取消已经定义的宏<code>LIMIT</code>，后面就可以重新用 LIMIT 定义一个宏。</p><p>有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用<code>#undef</code>取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而<code>#undef</code>的参数如果是不存在的宏，并不会报错。</p><p>GCC 的<code>-U</code>选项可以在命令行取消宏的定义，相当于<code>#undef</code>。</p><pre class="hljs"><code>$ gcc -ULIMIT foo.c
</code></pre><p>上面示例中的<code>-U</code>参数，取消了宏<code>LIMIT</code>，相当于源文件里面的<code>#undef LIMIT</code>。</p><h2 id="include">#include <a class="markdownIt-Anchor" href="#include">#</a></h2><p><code>#include</code>指令用于编译时将其他源码文件，加载进入当前文件。它有两种形式。</p><pre class="hljs"><code><span class="hljs-comment">// 形式一</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;foo.h&gt;</span> <span class="hljs-comment">// 加载系统提供的文件</span></span>

<span class="hljs-comment">// 形式二</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;foo.h&quot;</span> <span class="hljs-comment">// 加载用户提供的文件</span></span>
</code></pre><p>形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。</p><p>形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径，下面是一个例子。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;/usr/local/lib/foo.h&quot;</span></span>
</code></pre><p>GCC 编译器的<code>-I</code>参数，也可以用来指定<code>include</code>命令中用户文件的加载路径。</p><pre class="hljs"><code>$ gcc -Iinclude/ -o code code.c
</code></pre><p>上面命令中，<code>-Iinclude/</code>指定从当前目录的<code>include</code>子目录里面，加载用户自己的文件。</p><p><code>#include</code>最常见的用途，就是用来加载包含函数原型的头文件（后缀名为<code>.h</code>），参见《多文件编译》一章。多个<code>#include</code>指令的顺序无关紧要，多次包含同一个头文件也是合法的。</p><h2 id="ifendif">#if...#endif <a class="markdownIt-Anchor" href="#ifendif">#</a></h2><p><code>#if...#endif</code>指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span>
  <span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415</span>; <span class="hljs-comment">// 不会执行</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，<code>#if</code>后面的<code>0</code>，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。<code>#if 0</code>这种写法常用来当作注释使用，不需要的代码就放在<code>#if 0</code>里面。</p><p><code>#if</code>后面的判断条件，通常是一个表达式。如果表达式的值不等于<code>0</code>，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句。</p><p><code>#if...#endif</code>之间还可以加入<code>#else</code>指令，用于指定判断条件不成立时，需要编译的语句。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOO 1</span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> FOO</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;defined\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not defined\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，宏<code>FOO</code>如果定义过，会被替换成<code>1</code>，从而输出<code>defined</code>，否则输出<code>not defined</code>。</p><p>如果有多个判断条件，还可以加入<code>#elif</code>命令。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> HAPPY_FACTOR == 0</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m not happy!\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> HAPPY_FACTOR == 1</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m just regular\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m extra happy!\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，通过<code>#elif</code>指定了第二重判断。注意，<code>#elif</code>的位置必须在<code>#else</code>之前。如果多个判断条件皆不满足，则执行<code>#else</code>的部分。</p><p>没有定义过的宏，等同于<code>0</code>。因此如果<code>UNDEFINED</code>是一个没有定义过的宏，那么<code>#if UNDEFINED</code>为伪，而<code>#if !UNDEFINED</code>为真。</p><p><code>#if</code>的常见应用就是打开（或关闭）调试模式。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG 1</span>

<span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span>
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value of i : %d\n&quot;</span>, i);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;value of j : %d\n&quot;</span>, j);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，通过将<code>DEBUG</code>设为<code>1</code>，就打开了调试模式，可以输出调试信息。</p><p>GCC 的<code>-D</code>参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。</p><pre class="hljs"><code>$ gcc -DDEBUG=1 foo.c
</code></pre><p>上面示例中，<code>-D</code>参数指定宏<code>DEBUG</code>为<code>1</code>，相当于在代码中指定<code>#define DEBUG 1</code>。</p><h2 id="ifdefendif">#ifdef...#endif <a class="markdownIt-Anchor" href="#ifdefendif">#</a></h2><p><code>#ifdef...#endif</code>指令用于判断某个宏是否定义过。</p><p>有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用<code>#define</code>定义一个空的宏。通过这个宏，判断库文件是否被加载了。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXTRA_HAPPY</span>
</code></pre><p>上面示例中，<code>EXTRA_HAPPY</code>就是一个空的宏。</p><p>然后，源码文件使用<code>#ifdef...#endif</code>检查这个宏是否定义过。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> EXTRA_HAPPY</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m extra happy!\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，<code>#ifdef</code>检查宏<code>EXTRA_HAPPY</code>是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示。</p><p><code>#ifdef</code>可以与<code>#else</code>指令配合使用。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> EXTRA_HAPPY</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m extra happy!\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m just regular\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，如果宏<code>EXTRA_HAPPY</code>没有定义过，就会执行<code>#else</code>的部分。</p><p><code>#ifdef...#else...#endif</code>可以用来实现条件加载。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> MAVIS</span>
  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;foo.h&quot;</span></span>
  <span class="hljs-meta">#<span class="hljs-keyword">define</span> STABLES 1</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bar.h&quot;</span></span>
  <span class="hljs-meta">#<span class="hljs-keyword">define</span> STABLES 2</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，通过判断宏<code>MAVIS</code>是否定义过，实现加载不同的头文件。</p><h2 id="defined-运算符">defined 运算符 <a class="markdownIt-Anchor" href="#defined-运算符">#</a></h2><p>上一节的<code>#ifdef</code>指令，等同于<code>#if defined</code>。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FOO</span>
<span class="hljs-comment">// 等同于</span>
<span class="hljs-meta">#<span class="hljs-keyword">if</span> defined FOO</span>
</code></pre><p>上面示例中，<code>defined</code>是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。</p><p>使用这种语法，可以完成多重判断。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined FOO</span>
  x = <span class="hljs-number">2</span>;
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined BAR</span>
  x = <span class="hljs-number">3</span>;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>这个运算符的一个应用，就是对于不同架构的系统，加载不同的头文件。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined IBMPC</span>
  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ibmpc.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined MAC</span>
  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mac.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;general.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，不同架构的系统需要定义对应的宏。代码根据不同的宏，加载对应的头文件。</p><h2 id="ifndefendif">#ifndef...#endif <a class="markdownIt-Anchor" href="#ifndefendif">#</a></h2><p><code>#ifndef...#endif</code>指令跟<code>#ifdef...#endif</code>正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> EXTRA_HAPPY</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m extra happy!\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXTRA_HAPPY</span>
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I&#x27;m just regular\n&quot;</span>);
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，针对宏<code>EXTRA_HAPPY</code>是否被定义过，<code>#ifdef</code>和<code>#ifndef</code>分别指定了两种情况各自需要编译的代码。</p><p><code>#ifndef</code>常用于防止重复加载。举例来说，为了防止头文件<code>myheader.h</code>被重复加载，可以把它放在<code>#ifndef...#endif</code>里面加载。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MYHEADER_H</span>
  <span class="hljs-meta">#<span class="hljs-keyword">define</span> MYHEADER_H</span>
  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myheader.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，宏<code>MYHEADER_H</code>对应文件名<code>myheader.h</code>的大写。只要<code>#ifndef</code>发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏<code>MYHEADER_H</code>，防止被再次加载。</p><p><code>#ifndef</code>等同于<code>#if !defined</code>。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FOO</span>
<span class="hljs-comment">// 等同于</span>
<span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined FOO</span>
</code></pre><h2 id="预定义宏">预定义宏 <a class="markdownIt-Anchor" href="#预定义宏">#</a></h2><p>C 语言提供一些预定义的宏，可以直接使用。</p><ul><li><code>__DATE__</code>：编译日期，格式为“Mmm dd yyyy”的字符串（比如 Nov 23 2021）。</li><li><code>__TIME__</code>：编译时间，格式为“hh:mm:ss”。</li><li><code>__FILE__</code>：当前文件名。</li><li><code>__LINE__</code>：当前行号。</li><li><code>__func__</code>：当前正在执行的函数名。该预定义宏必须在函数作用域使用。</li><li><code>__STDC__</code>：如果被设为1，表示当前编译器遵循 C 标准。</li><li><code>__STDC_HOSTED__</code>：如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）。</li><li><code>__STDC_VERSION__</code>：编译所使用的 C 语言版本，是一个格式为<code>yyyymmL</code>的长整数，C99 版本为“199901L”，C11 版本为“201112L”，C17 版本为“201710L”。</li></ul><p>下面示例打印这些预定义宏的值。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This function: %s\n&quot;</span>, __func__);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file: %s\n&quot;</span>, __FILE__);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This line: %d\n&quot;</span>, __LINE__);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Compiled on: %s %s\n&quot;</span>, __DATE__, __TIME__);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C Version: %ld\n&quot;</span>, __STDC_VERSION__);
}

<span class="hljs-comment">/* 输出如下

This function: main
This file: test.c
This line: 7
Compiled on: Mar 29 2021 19:19:37
C Version: 201710

*/</span>
</code></pre><h2 id="line">#line <a class="markdownIt-Anchor" href="#line">#</a></h2><p><code>#line</code>指令用于覆盖预定义宏<code>__LINE__</code>，将其改为自定义的行号。后面的行将从<code>__LINE__</code>的新值开始计数。</p><pre class="hljs"><code><span class="hljs-comment">// 将下一行的行号重置为 300</span>
<span class="hljs-meta">#<span class="hljs-keyword">line</span> 300</span>
</code></pre><p>上面示例中，紧跟在<code>#line 300</code>后面一行的行号，将被改成300，其后的行会在300的基础上递增编号。</p><p><code>#line</code>还可以改掉预定义宏<code>__FILE__</code>，将其改为自定义的文件名。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">line</span> 300 <span class="hljs-string">&quot;newfilename&quot;</span></span>
</code></pre><p>上面示例中，下一行的行号重置为<code>300</code>，文件名重置为<code>newfilename</code>。</p><h2 id="error">#error <a class="markdownIt-Anchor" href="#error">#</a></h2><p><code>#error</code>指令用于让预处理器抛出一个错误，终止编译。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> __STDC_VERSION__ != 201112L</span>
  <span class="hljs-meta">#<span class="hljs-keyword">error</span> Not C11</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例指定，如果编译器不使用 C11 标准，就中止编译。GCC 编译器会像下面这样报错。</p><pre class="hljs"><code>$ gcc -std=c99 newish.c
newish.c:14:2: error: <span class="hljs-comment">#error Not C11</span>
</code></pre><p>上面示例中，GCC 使用 C99 标准编译，就报错了。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> INT_MAX &lt; 100000</span>
  <span class="hljs-meta">#<span class="hljs-keyword">error</span> int type is too small</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><p>上面示例中，编译器一旦发现<code>INT</code>类型的最大值小于<code>100,000</code>，就会停止编译。</p><p><code>#error</code>指令也可以用在<code>#if...#elif...#else</code>的部分。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined WIN32</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined MAC_OS</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined LINUX</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
  <span class="hljs-meta">#<span class="hljs-keyword">error</span> NOT support the operating system</span>
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre><h2 id="pragma">#pragma <a class="markdownIt-Anchor" href="#pragma">#</a></h2><p><code>#pragma</code>指令用来修改编译器属性。</p><pre class="hljs"><code><span class="hljs-comment">// 使用 C99 标准</span>
<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> c9x on</span>
</code></pre><p>上面示例让编译器以 C99 标准进行编译。</p></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="enum.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Enum 类型</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="io.html">I/O 函数 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> C 语言教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="syntax.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本语法</span></a></li><li><a href="variable.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">变量</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">运算符</span></a></li><li><a href="flow-control.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">流程控制</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数据类型</span></a></li><li><a href="pointer.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">指针</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串</span></a></li><li><a href="memory.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">内存管理</span></a></li><li><a href="struct.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">struct 结构</span></a></li><li><a href="typedef.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">typedef 命令</span></a></li><li><a href="union.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Union 结构</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="preprocessor.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">预处理器</span></a></li><li><a href="io.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">I/O 函数</span></a></li><li><a href="file.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">文件操作</span></a></li><li><a href="specifier.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">变量说明符</span></a></li><li><a href="multifile.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">多文件项目</span></a></li><li><a href="cli.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">命令行环境</span></a></li><li><a href="multibyte.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">多字节字符</span></a></li><li><a href="lib/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">标准库</span></a><ul><li><a href="lib/assert.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">assert.h</span></a></li><li><a href="lib/ctype.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">ctype.h</span></a></li><li><a href="lib/errno.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">errno.h</span></a></li><li><a href="lib/float.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">float.h</span></a></li><li><a href="lib/inttypes.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">inttypes.h</span></a></li><li><a href="lib/iso646.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">iso646.h</span></a></li><li><a href="lib/limits.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">limits.h</span></a></li><li><a href="lib/locale.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">locale.h</span></a></li><li><a href="lib/math.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">math.h</span></a></li><li><a href="lib/signal.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">signal.h</span></a></li><li><a href="lib/stdint.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">stdint.h</span></a></li><li><a href="lib/stdlib.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">stdlib.h</span></a></li><li><a href="lib/stdio.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">stdio.h</span></a></li><li><a href="lib/string.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">string.h</span></a></li><li><a href="lib/time.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">time.h</span></a></li><li><a href="lib/wchar.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">wchar.h</span></a></li><li><a href="lib/wctype.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">wctype.h</span></a></li></ul></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/clang-tutorial/master/docs/preprocessor.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/clang-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/clang-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"preprocessor.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>\n<li><a href="#define">#define</a></li>\n<li><a href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F">带参数的宏</a>\n<ul>\n<li><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">基本用法</a></li>\n<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6"><code>#</code>运算符，<code>##</code>运算符</a></li>\n<li><a href="#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F">不定参数的宏</a></li>\n</ul>\n</li>\n<li><a href="#undef">#undef</a></li>\n<li><a href="#include">#include</a></li>\n<li><a href="#ifendif">#if...#endif</a></li>\n<li><a href="#ifdefendif">#ifdef...#endif</a></li>\n<li><a href="#defined-%E8%BF%90%E7%AE%97%E7%AC%A6">defined 运算符</a></li>\n<li><a href="#ifndefendif">#ifndef...#endif</a></li>\n<li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F">预定义宏</a></li>\n<li><a href="#line">#line</a></li>\n<li><a href="#error">#error</a></li>\n<li><a href="#pragma">#pragma</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-clang.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《预处理器（Preprocessor）》，出自网道（WangDoc.com）的《C 语言教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>