<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>文件操作 - C 语言教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="文件操作"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/clang-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/clang-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;C 语言教程</a></li><li class="is-active"><a class="has-text-grey" href="file.html">文件操作</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="io.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> I/O 函数</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="specifier.html">变量说明符 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">文件操作</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><p>本章介绍 C 语言如何操作文件。</p><h2 id="文件指针">文件指针 <a class="markdownIt-Anchor" href="#文件指针">#</a></h2><p>C 语言提供了一个 FILE 数据结构，记录了操作一个文件所需要的信息。该结构定义在头文件<code>stdio.h</code>，所有文件操作函数都要通过这个数据结构，获取文件信息。</p><p>开始操作一个文件之前，就要定义一个指向该文件的 FILE 指针，相当于获取一块内存区域，用来保存文件信息。</p><pre class="hljs"><code>FILE* fp;
</code></pre><p>上面示例定义了一个 FILE 指针<code>fp</code>。</p><p>下面是一个读取文件的完整示例。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  FILE* fp;
  <span class="hljs-type">char</span> c;

  fp = fopen(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
  <span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }

  c = fgetc(fp);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c\n&quot;</span>, c);

  fclose(fp);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre><p>上面示例中，新建文件指针<code>fp</code>以后，依次使用了下面三个文件操作函数，分成三个步骤。其他的文件操作，大致上也是这样的步骤。</p><p>第一步，使用<code>fopen()</code>打开指定文件，返回一个 File 指针。如果出错，返回 NULL。</p><p>它相当于将指定文件的信息与新建的文件指针<code>fp</code>相关联，在 FILE 结构内部记录了这样一些信息：文件内部的当前读写位置、读写报错的记录、文件结尾指示器、缓冲区开始位置的指针、文件标识符、一个计数器（统计拷贝进缓冲区的字节数）等等。后继的操作就可以使用这个指针（而不是文件名）来处理指定文件。</p><p>同时，它还为文件建立一个缓存区。由于存在缓存区，也可以说<code>fopen()</code>函数“打开一个了流”，后继的读写文件都是流模式。</p><p>第二步，使用读写函数，从文件读取数据，或者向文件写入数据。上例使用了<code>fgetc()</code>函数，从已经打开的文件里面，读取一个字符。</p><p><code>fgetc()</code>一调用，文件的数据块先拷贝到缓冲区。不同的计算机有不同的缓冲区大小，一般是512字节或是它的倍数，如4096或16384。随着计算机硬盘容量越来越大，缓冲区也越来越大。</p><p><code>fgetc()</code>从缓冲区读取数据，同时将文件指针内部的读写位置指示器，指向所读取字符的下一个字符。所有的文件读取函数都使用相同的缓冲区，后面再调用任何一个读取函数，都将从指示器指向的位置，即上一次读取函数停止的位置开始读取。</p><p>当读取函数发现已读完缓冲区里面的所有字符时，会请求把下一个缓冲区大小的数据块，从文件拷贝到缓冲区中。读取函数就以这种方式，读完文件的所有内容，直到文件结尾。不过，上例是只从缓存区读取一个字符。当函数在缓冲区里面，读完文件的最后一个字符时，就把 FILE 结构里面的文件结尾指示器设置为真。于是，下一次再调用读取函数时，会返回常量 EOF。EOF 是一个整数值，代表文件结尾，一般是<code>-1</code>。</p><p>第三步，<code>fclose()</code>关闭文件，同时清空缓存区。</p><p>上面是文件读取的过程，文件写入也是类似的方式，先把数据写入缓冲区，当缓冲区填满后，缓存区的数据将被转移到文件中。</p><h2 id="fopen">fopen() <a class="markdownIt-Anchor" href="#fopen">#</a></h2><p><code>fopen()</code>函数用来打开文件。所有文件操作的第一步，都是使用<code>fopen()</code>打开指定文件。这个函数的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code>FILE* <span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">char</span>* filename, <span class="hljs-type">char</span>* mode)</span>;
</code></pre><p>它接受两个参数。第一个参数是文件名(可以包含路径)，第二个参数是模式字符串，指定对文件执行的操作，比如下面的例子中，<code>r</code>表示以读取模式打开文件。</p><pre class="hljs"><code>fp = fopen(<span class="hljs-string">&quot;in.dat&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);
</code></pre><p>成功打开文件以后，<code>fopen()</code>返回一个 FILE 指针，其他函数可以用这个指针操作文件。如果无法打开文件（比如文件不存在或没有权限），会返回空指针 NULL。所以，执行<code>fopen()</code>以后，最好判断一下，有没有打开成功。</p><pre class="hljs"><code>fp = fopen(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);

<span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>) {
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t open file!\n&quot;</span>);
  <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
}
</code></pre><p>上面示例中，如果<code>fopen()</code>返回一个空指针，程序就会报错。</p><p><code>fopen()</code>的模式字符串有以下几种。</p><ul><li><code>r</code>：读模式，只用来读取数据。如果文件不存在，返回 NULL 指针。</li><li><code>w</code>：写模式，只用来写入数据。如果文件存在，文件长度会被截为0，然后再写入；如果文件不存在，则创建该文件。</li><li><code>a</code>：写模式，只用来在文件尾部追加数据。如果文件不存在，则创建该文件。</li><li><code>r+</code>：读写模式。如果文件存在，指针指向文件开始处，可以在文件头部添加数据。如果文件不存在，返回 NULL 指针。</li><li><code>w+</code>：读写模式。如果文件存在，文件长度会被截为0，然后再写入数据。这种模式实际上读不到数据，反而会擦掉数据。如果文件不存在，则创建该文件。</li><li><code>a+</code>：读写模式。如果文件存在，指针指向文件结尾，可以在现有文件末尾添加内容。如果文件不存在，则创建该文件。</li></ul><p>上一小节说过，<code>fopen()</code>函数会为打开的文件创建一个缓冲区。读模式下，创建的是读缓存区；写模式下，创建的是写缓存区；读写模式下，会同时创建两个缓冲区。C 语言通过缓存区，以流的形式，向文件读写数据。</p><p>数据在文件里面，都是以二进制形式存储。但是，读取的时候，有不同的解读方法：以原本的二进制形式解读，叫做“二进制流”；将二进制数据转成文本，以文本形式解读，叫做“文本流”。写入操作也是如此，分成以二进制写入和以文本写入，后者会多一个文本转二进制的步骤。</p><p><code>fopen()</code>的模式字符串，默认是以文本流读写。如果添加<code>b</code>后缀（表示 binary），就会以“二进制流”进行读写。比如，<code>rb</code>是读取二进制数据模式，<code>wb</code>是写入二进制数据模式。</p><p>模式字符串还有一个<code>x</code>后缀，表示独占模式（exclusive）。如果文件已经存在，则打开文件失败；如果文件不存在，则新建文件，打开后不再允许其他程序或线程访问当前文件。比如，<code>wx</code>表示以独占模式写入文件，如果文件已经存在，就会打开失败。</p><h2 id="标准流">标准流 <a class="markdownIt-Anchor" href="#标准流">#</a></h2><p>Linux 系统默认提供三个已经打开的文件，它们的文件指针如下。</p><ul><li><code>stdin</code>（标准输入）：默认来源为键盘，文件指针编号为<code>0</code>。</li><li><code>stdout</code>（标准输出）：默认目的地为显示器，文件指针编号为<code>1</code>。</li><li><code>stderr</code>（标准错误）：默认目的地为显示器，文件指针编号为<code>2</code>。</li></ul><p>Linux 系统的文件，不一定是数据文件，也可以是设备文件，即文件代表一个可以读或写的设备。文件指针<code>stdin</code>默认是把键盘看作一个文件，读取这个文件，就能获取用户的键盘输入。同理，<code>stdout</code>和<code>stderr</code>默认是把显示器看作一个文件，将程序的运行结果写入这个文件，用户就能看到运行结果了。它们的区别是，<code>stdout</code>写入的是程序的正常运行结果，<code>stderr</code>写入的是程序的报错信息。</p><p>这三个输入和输出渠道，是 Linux 默认提供的，所以分别称为标准输入（stdin）、标准输出（stdout）和标准错误（stderr）。因为它们的实现是一样的，都是文件流，所以合称为“标准流”。</p><p>Linux 允许改变这三个文件指针（文件流）指向的文件，这称为重定向（redirection）。</p><p>如果标准输入不绑定键盘，而是绑定其他文件，可以在文件名前面加上小于号<code>&lt;</code>，跟在程序名后面。这叫做“输入重定向”（input redirection）。</p><pre class="hljs"><code>$ demo &lt; in.dat
</code></pre><p>上面示例中，<code>demo</code>程序代码里面的<code>stdin</code>，将指向文件<code>in.dat</code>，即从<code>in.dat</code>获取数据。</p><p>如果标准输出绑定其他文件，而不是显示器，可以在文件名前加上大于号<code>&gt;</code>，跟在程序名后面。这叫做“输出重定向”（output redirection）。</p><pre class="hljs"><code>$ demo &gt; out.dat
</code></pre><p>上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将指向文件<code>out.dat</code>，即向<code>out.dat</code>写入数据。</p><p>输出重定向<code>&gt;</code>会先擦去<code>out.dat</code>的所有原有的内容，然后再写入。如果希望写入的信息追加在<code>out.dat</code>的结尾，可以使用<code>&gt;&gt;</code>符号。</p><pre class="hljs"><code>$ demo &gt;&gt; out.dat
</code></pre><p>上面示例中，<code>demo</code>程序代码里面的<code>stdout</code>，将向文件<code>out.dat</code>写入数据。与<code>&gt;</code>不同的是，写入的开始位置是<code>out.dat</code>的文件结尾。</p><p>标准错误的重定向符号是<code>2&gt;</code>。其中的<code>2</code>代表文件指针的编号，即<code>2&gt;</code>表示将2号文件指针的写入，重定向到<code>err.txt</code>。2号文件指针就是标准错误<code>stderr</code>。</p><pre class="hljs"><code>$ demo &gt; out.dat 2&gt; err.txt
</code></pre><p>上面示例中，<code>demo</code>程序代码里面的<code>stderr</code>，会向文件<code>err.txt</code>写入报错信息。而<code>stdout</code>向文件<code>out.dat</code>写入。</p><p>输入重定向和输出重定向，也可以结合在一条命令里面。</p><pre class="hljs"><code>$ demo &lt; in.dat &gt; out.dat

// or
$ demo &gt; out.dat &lt; in.dat
</code></pre><p>重定向还有另一种情况，就是将一个程序的标准输出<code>stdout</code>，指向另一个程序的标准输入<code>stdin</code>，这时要使用<code>|</code>符号。</p><pre class="hljs"><code>$ random | <span class="hljs-built_in">sum</span>
</code></pre><p>上面示例中，<code>random</code>程序代码里面的<code>stdout</code>的写入，会从<code>sum</code>程序代码里面的<code>stdin</code>被读取。</p><h2 id="fclose">fclose() <a class="markdownIt-Anchor" href="#fclose">#</a></h2><p><code>fclose()</code>用来关闭已经使用<code>fopen()</code>打开的文件。它的原型定义在<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE* stream)</span>;
</code></pre><p>它接受一个文件指针<code>fp</code>作为参数。如果成功关闭文件，<code>fclose()</code>函数返回整数<code>0</code>；如果操作失败（比如磁盘已满，或者出现 I/O 错误），则返回一个特殊值 EOF（详见下一小节）。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (fclose(fp) != <span class="hljs-number">0</span>)
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something wrong.&quot;</span>);
</code></pre><p>不再使用的文件，都应该使用<code>fclose()</code>关闭，否则无法释放资源。一般来说，系统对同时打开的文件数量有限制，及时关闭文件可以避免超过这个限制。</p><h2 id="eof">EOF <a class="markdownIt-Anchor" href="#eof">#</a></h2><p>C 语言的文件操作函数的设计是，如果遇到文件结尾，就返回一个特殊值。程序接收到这个特殊值，就知道已经到达文件结尾了。</p><p>头文件<code>stdio.h</code>为这个特殊值定义了一个宏<code>EOF</code>（end of file 的缩写），它的值一般是<code>-1</code>。这是因为从文件读取的二进制值，不管作为无符号数字解释，还是作为 ASCII 码解释，都不可能是负值，所以可以很安全地返回<code>-1</code>，不会跟文件本身的数据相冲突。</p><p>需要注意的是，不像字符串结尾真的存储了<code>\0</code>这个值，<code>EOF</code>并不存储在文件结尾，文件中并不存在这个值，完全是文件操作函数发现到达了文件结尾，而返回这个值。</p><h2 id="freopen">freopen() <a class="markdownIt-Anchor" href="#freopen">#</a></h2><p><code>freopen()</code>用于新打开一个文件，直接关联到某个已经打开的文件指针。这样可以复用文件指针。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code>FILE* <span class="hljs-title function_">freopen</span><span class="hljs-params">(<span class="hljs-type">char</span>* filename, <span class="hljs-type">char</span>* mode, FILE stream)</span>;
</code></pre><p>它跟<code>fopen()</code>相比，就是多出了第三个参数，表示要复用的文件指针。其他两个参数都一样，分别是文件名和打开模式。</p><pre class="hljs"><code>freopen(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello&quot;</span>);
</code></pre><p>上面示例将文件<code>output.txt</code>关联到<code>stdout</code>，此后向<code>stdout</code>写入的内容，都会写入<code>output.txt</code>。由于<code>printf()</code>默认就是输出到<code>stdout</code>，所以运行上面的代码以后，文件<code>output.txt</code>会被写入<code>hello</code>。</p><p><code>freopen()</code>的返回值是它的第三个参数（文件指针）。如果打开失败（比如文件不存在），会返回空指针 NULL。</p><p><code>freopen()</code>会自动关闭原先已经打开的文件，如果文件指针并没有指向已经打开的文件，则<code>freopen()</code>等同于<code>fopen()</code>。</p><p>下面是<code>freopen()</code>关联<code>scanf()</code>的例子。</p><pre class="hljs"><code><span class="hljs-type">int</span> i, i2;

<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;i); 

freopen(<span class="hljs-string">&quot;someints.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);
<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;i2);
</code></pre><p>上面例子中，一共调用了两次<code>scanf()</code>，第一次调用是从键盘读取，然后使用<code>freopen()</code>将<code>stdin</code>指针关联到某个文件，第二次调用就会从该文件读取。</p><p>某些系统允许使用<code>freopen()</code>，改变文件的打开模式。这时，<code>freopen()</code>的第一个参数应该是 NULL。</p><pre class="hljs"><code>freopen(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;wb&quot;</span>, <span class="hljs-built_in">stdout</span>);
</code></pre><p>上面示例将<code>stdout</code>的打开模式从<code>w</code>改成了<code>wb</code>。</p><h2 id="fgetcgetc">fgetc()，getc() <a class="markdownIt-Anchor" href="#fgetcgetc">#</a></h2><p><code>fgetc()</code>和<code>getc()</code>用于从文件读取一个字符。它们的用法跟<code>getchar()</code>类似，区别是<code>getchar()</code>只用来从<code>stdin</code>读取，而这两个函数是从任意指定的文件读取。它们的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fgetc</span><span class="hljs-params">(FILE *stream)</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">getc</span><span class="hljs-params">(FILE *stream)</span>;
</code></pre><p><code>fgetc()</code>与<code>getc()</code>的用法是一样的，都只有文件指针一个参数。两者的区别是，<code>getc()</code>一般用宏来实现，而<code>fgetc()</code>是函数实现，所以前者的性能可能更好一些。注意，虽然这两个函数返回的是一个字符，但是它们的返回值类型却不是<code>char</code>，而是<code>int</code>，这是因为读取失败的情况下，它们会返回 EOF，这个值一般是<code>-1</code>。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  FILE *fp;
  fp = fopen(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);

  <span class="hljs-type">int</span> c;
  <span class="hljs-keyword">while</span> ((c = getc(fp)) != EOF)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);

  fclose(fp);
}
</code></pre><p>上面示例中，<code>getc()</code>依次读取文件的每个字符，将其放入变量<code>c</code>，直到读到文件结尾，返回 EOF，循环终止。变量<code>c</code>的类型是<code>int</code>，而不是<code>char</code>，因为有可能等于负值，所以设为<code>int</code>更好一些。</p><h2 id="fputcputc">fputc()，putc() <a class="markdownIt-Anchor" href="#fputcputc">#</a></h2><p><code>fputc()</code>和<code>putc()</code>用于向文件写入一个字符。它们的用法跟<code>putchar()</code>类似，区别是<code>putchar()</code>是向<code>stdout</code>写入，而这两个函数是向文件写入。它们的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-type">char</span>, FILE *stream)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">putc</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-type">char</span>, FILE *stream)</span>;
</code></pre><p><code>fputc()</code>与<code>putc()</code>的用法是一样，都接受两个参数，第一个参数是待写入的字符，第二个参数是文件指针。它们的区别是，<code>putc()</code>通常是使用宏来实现，而<code>fputc()</code>只作为函数来实现，所以理论上，<code>putc()</code>的性能会好一点。</p><p>写入成功时，它们返回写入的字符；写入失败时，返回 EOF。</p><h2 id="fprintf">fprintf() <a class="markdownIt-Anchor" href="#fprintf">#</a></h2><p><code>fprintf()</code>用于向文件写入格式化字符串，用法与<code>printf()</code>类似。区别是<code>printf()</code>总是写入<code>stdout</code>，而<code>fprintf()</code>则是写入指定的文件，它的第一个参数必须是一个文件指针。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fprintf</span><span class="hljs-params">(FILE* stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>
</code></pre><p><code>fprintf()</code>可以替代<code>printf()</code>。</p><pre class="hljs"><code><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>);
<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;Hello, world!\n&quot;</span>);
</code></pre><p>上面例子中，指定<code>fprintf()</code>写入<code>stdout</code>，结果就等同于调用<code>printf()</code>。</p><pre class="hljs"><code><span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;Sum: %d\n&quot;</span>, sum);
</code></pre><p>上面示例是向文件指针<code>fp</code>写入指定格式的字符串。</p><p>下面是向<code>stderr</code>输出错误信息的例子。</p><pre class="hljs"><code><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Something number.\n&quot;</span>);
</code></pre><h2 id="fscanf">fscanf() <a class="markdownIt-Anchor" href="#fscanf">#</a></h2><p><code>fscanf()</code>用于按照给定的模式，从文件中读取内容，用法跟<code>scanf()</code>类似。区别是<code>scanf()</code>总是从<code>stdin</code>读取数据，而<code>fscanf()</code>是从文件读入数据，它的原型定义在头文件<code>stdio.h</code>，第一个参数必须是文件指针。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fscanf</span><span class="hljs-params">(FILE* stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>;
</code></pre><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%d%d&quot;</span>, &amp;i, &amp;j);
</code></pre><p>上面示例中，<code>fscanf()</code>从文件<code>fp</code>里面，读取两个整数，放入变量<code>i</code>和<code>j</code>。</p><p>使用<code>fscanf()</code>的前提是知道文件的结构，它的占位符解析规则与<code>scanf()</code>完全一致。由于<code>fscanf()</code>可以连续读取，直到读到文件尾，或者发生错误（读取失败、匹配失败），才会停止读取，所以<code>fscanf()</code>通常放在循环里面。</p><pre class="hljs"><code><span class="hljs-keyword">while</span>(<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%s&quot;</span>, words) == <span class="hljs-number">1</span>)
  <span class="hljs-built_in">puts</span>(words);
</code></pre><p>上面示例中，<code>fscanf()</code>依次读取文件的每个词，将它们一行打印一个，直到文件结束。</p><p><code>fscanf()</code>的返回值是赋值成功的变量数量，如果赋值失败会返回 EOF。</p><h2 id="fgets">fgets() <a class="markdownIt-Anchor" href="#fgets">#</a></h2><p><code>fgets()</code>用于从文件读取指定长度的字符串，它名字的第一个字符是<code>f</code>，就代表<code>file</code>。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">char</span>* <span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">int</span> STRLEN, File* fp)</span>;
</code></pre><p>它的第一个参数<code>str</code>是一个字符串指针，用于存放读取的内容。第二个参数<code>STRLEN</code>指定读取的长度，第三个参数是一个 FILE 指针，指向要读取的文件。</p><p><code>fgets()</code>读取 STRLEN - 1 个字符之后，或者遇到换行符与文件结尾，就会停止读取，然后在已经读取的内容末尾添加一个空字符<code>\0</code>，使之成为一个字符串。注意，<code>fgets()</code>会将换行符（<code>\n</code>）存储进字符串。</p><p>如果<code>fgets</code>的第三个参数是<code>stdin</code>，就可以读取标准输入，等同于<code>scanf()</code>。</p><pre class="hljs"><code>fgets(str, <span class="hljs-keyword">sizeof</span>(str), <span class="hljs-built_in">stdin</span>);
</code></pre><p>读取成功时，<code>fgets()</code>的返回值是它的第一个参数，即指向字符串的指针，否则返回空指针 NULL。</p><p><code>fgets()</code>可以用来读取文件的每一行，下面是读取文件所有行的例子。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  FILE* fp;
  <span class="hljs-type">char</span> s[<span class="hljs-number">1024</span>];  <span class="hljs-comment">// 数组必须足够大，足以放下一行</span>
  <span class="hljs-type">int</span> linecount = <span class="hljs-number">0</span>;

  fp = fopen(<span class="hljs-string">&quot;hello.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);

  <span class="hljs-keyword">while</span> (fgets(s, <span class="hljs-keyword">sizeof</span> s, fp) != <span class="hljs-literal">NULL</span>)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: %s&quot;</span>, ++linecount, s);

  fclose(fp);
}
</code></pre><p>上面示例中，每读取一行，都会输出行号和该行的内容。</p><p>下面的例子是循环读取用户的输入。</p><pre class="hljs"><code><span class="hljs-type">char</span> words[<span class="hljs-number">10</span>];

<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter strings (q to quit):&quot;</span>);

<span class="hljs-keyword">while</span> (fgets(words, <span class="hljs-number">10</span>, <span class="hljs-built_in">stdin</span>) != <span class="hljs-literal">NULL</span>) {
  <span class="hljs-keyword">if</span> (words[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;q&#x27;</span> &amp;&amp; words[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>)
    <span class="hljs-keyword">break</span>;

  <span class="hljs-built_in">puts</span>(words);
}

<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done.&quot;</span>);
</code></pre><p>上面的示例中，如果用户输入的字符串大于9个字符，<code>fgets()</code>会多次读取。直到遇到<code>q</code> + 回车键，才会退出循环。</p><h2 id="fputs">fputs() <a class="markdownIt-Anchor" href="#fputs">#</a></h2><p><code>fputs()</code>函数用于向文件写入字符串，和<code>puts()</code>函数只有一点不同，那就是它不会在字符串末尾添加换行符。这是因为<code>fgets()</code>保留了换行符，所以<code>fputs()</code>就不添加了。<code>fputs()</code>函数通常与<code>fgets()</code>配对使用。</p><p>它的原型定义在<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fputs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, FILE* stream)</span>;
</code></pre><p>它接受两个参数，第一个参数是字符串指针，第二个参数是要写入的文件指针。如果第二个参数为<code>stdout</code>（标准输出），就是将内容输出到计算机屏幕，等同于<code>printf()</code>。</p><pre class="hljs"><code><span class="hljs-type">char</span> words[<span class="hljs-number">14</span>];

<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Enter a string, please.&quot;</span>);
fgets(words, <span class="hljs-number">14</span>, <span class="hljs-built_in">stdin</span>);

<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This is your string:&quot;</span>);
<span class="hljs-built_in">fputs</span>(words, <span class="hljs-built_in">stdout</span>);
</code></pre><p>上面示例中，先用<code>fgets()</code>从<code>stdin</code>读取用户输入，然后用<code>fputs()</code>输出到<code>stdout</code>。</p><p>写入成功时，<code>fputs()</code>返回一个非负整数，否则返回 EOF。</p><h2 id="fwrite">fwrite() <a class="markdownIt-Anchor" href="#fwrite">#</a></h2><p><code>fwrite()</code>用来一次性写入较大的数据块，主要用途是将数组数据一次性写入文件，适合写入二进制数据。它的原型定义在<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(
  <span class="hljs-type">const</span> <span class="hljs-type">void</span>* ptr,
  <span class="hljs-type">size_t</span> size,
  <span class="hljs-type">size_t</span> nmemb,
  FILE* fp
)</span>;
</code></pre><p>它接受四个参数。</p><ul><li><code>ptr</code>：数组指针。</li><li><code>size</code>：每个数组成员的大小，单位字节。</li><li><code>nmemb</code>：数组成员的数量。</li><li><code>fp</code>：要写入的文件指针。</li></ul><p>注意，<code>fwrite()</code>原型的第一个参数类型是<code>void*</code>，这是一个无类型指针，编译器会自动将参数指针转成<code>void*</code>类型。正是由于<code>fwrite()</code>不知道数组成员的类型，所以才需要知道每个成员的大小（第二个参数）和成员数量（第三个参数）。</p><p><code>fwrite()</code>函数的返回值是成功写入的数组成员的数量（注意不是字节数）。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现写入错误，只写入了一部分成员，返回值会比<code>nmemb</code>小。</p><p>要将整个数组<code>arr</code>写入文件，可以采用下面的写法。</p><pre class="hljs"><code>fwrite(
  arr,
  <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]),
  <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]),
  fp
);
</code></pre><p>上面示例中，<code>sizeof(a[0])</code>是每个数组成员占用的字节，<code>sizeof(a) / sizeof(a[0])</code>是整个数组的成员数量。</p><p>下面的例子是将一个大小为256字节的字符串写入文件。</p><pre class="hljs"><code><span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];

fwrite(buffer, <span class="hljs-number">1</span>, <span class="hljs-number">256</span>, fp);
</code></pre><p>上面示例中，数组<code>buffer</code>每个成员是1个字节，一共有256个成员。由于<code>fwrite()</code>是连续内存复制，所以写成<code>fwrite(buffer, 256, 1, fp)</code>也能达到目的。</p><p><code>fwrite()</code>没有规定一定要写入整个数组，只写入数组的一部分也是可以的。</p><p>任何类型的数据都可以看成是1字节数据组成的数组，或者是一个成员的数组，所以<code>fwrite()</code>实际上可以写入任何类型的数据，而不仅仅是数组。比如，<code>fwrite()</code>可以将一个 Struct 结构写入文件保存。</p><pre class="hljs"><code>fwrite(&amp;s, <span class="hljs-keyword">sizeof</span>(s), <span class="hljs-number">1</span>, fp);
</code></pre><p>上面示例中，<code>s</code>是一个 Struct 结构指针，可以看成是一个成员的数组。注意，如果<code>s</code>的属性包含指针，存储时需要小心，因为保存指针可能没意义，还原出来的时候，并不能保证指针指向的数据还存在。</p><p><code>fwrite()</code>以及后面要介绍的<code>fread()</code>，比较适合读写二进制数据，因为它们不会对写入的数据进行解读。二进制数据可能包含空字符<code>\0</code>，这是 C 语言的字符串结尾标记，所以读写二进制文件，不适合使用文本读写函数（比如<code>fprintf()</code>等）。</p><p>下面是一个写入二进制文件的例子。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  FILE* fp;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> bytes[] = {<span class="hljs-number">5</span>, <span class="hljs-number">37</span>, <span class="hljs-number">0</span>, <span class="hljs-number">88</span>, <span class="hljs-number">255</span>, <span class="hljs-number">12</span>};

  fp = fopen(<span class="hljs-string">&quot;output.bin&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);
  fwrite(bytes, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-keyword">sizeof</span>(bytes), fp);
  fclose(fp);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre><p>上面示例中，写入二进制文件时，<code>fopen()</code>要使用<code>wb</code>模式打开，表示二进制写入。<code>fwrite()</code>可以把数据解释成单字节数组，因此它的第二个参数是<code>sizeof(char)</code>，第三个参数是数组的总字节数<code>sizeof(bytes)</code>。</p><p>上面例子写入的文件<code>output.bin</code>，使用十六进制编辑器打开，会是下面的内容。</p><pre class="hljs"><code><span class="hljs-number">05</span> <span class="hljs-number">25</span> <span class="hljs-number">00</span> <span class="hljs-number">58</span> ff <span class="hljs-number">0</span>c
</code></pre><p><code>fwrite()</code>还可以连续向一个文件写入数据。</p><pre class="hljs"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">clientData</span> <span class="hljs-title">myClient</span> =</span> {<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo bar&#x27;</span>};

<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  fwrite(&amp;myClient, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> clientData), <span class="hljs-number">1</span>, cfPtr);
}
</code></pre><p>上面示例中，<code>fwrite()</code>连续将100条数据写入文件。</p><h2 id="fread">fread() <a class="markdownIt-Anchor" href="#fread">#</a></h2><p><code>fread()</code>函数用于一次性从文件读取较大的数据块，主要用途是将文件内容读入一个数组，适合读取二进制数据。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span><span class="hljs-params">(
  <span class="hljs-type">void</span>* ptr,
  <span class="hljs-type">size_t</span> size,
  <span class="hljs-type">size_t</span> nmemb,
  FILE* fp
)</span>;
</code></pre><p>它接受四个参数，与<code>fwrite()</code>完全相同。</p><ul><li><code>ptr</code>：数组地址。</li><li><code>size</code>：每个数组成员的大小，单位为字节。</li><li><code>nmemb</code>：数组的成员数量。</li><li><code>fp</code>：文件指针。</li></ul><p>要将文件内容读入数组<code>arr</code>，可以采用下面的写法。</p><pre class="hljs"><code>fread(
  arr,
  <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]),
  <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]),
  fp
);
</code></pre><p>上面示例中，数组长度（第二个参数）和每个成员的大小（第三个参数）的乘积，就是数组占用的内存空间的大小。<code>fread()</code>会从文件（第四个参数）里面读取相同大小的内容，然后将<code>ptr</code>（第一个参数）指向这些内容的内存地址。</p><p>下面的例子是将文件内容读入一个10个成员的双精度浮点数数组。</p><pre class="hljs"><code><span class="hljs-type">double</span> earnings[<span class="hljs-number">10</span>];
fread(earnings, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">double</span>), <span class="hljs-number">10</span>, fp);
</code></pre><p>上面示例中，每个数组成员的大小是<code>sizeof(double)</code>，一个有10个成员，就会从文件<code>fp</code>读取<code>sizeof(double) * 10</code>大小的内容。</p><p><code>fread()</code>函数的返回值是成功读取的数组成员的数量。正常情况下，该返回值就是第三个参数<code>nmemb</code>，但如果出现读取错误或读到文件结尾，该返回值就会比<code>nmemb</code>小。所以，检查<code>fread()</code>的返回值是非常重要的。</p><p><code>fread()</code>和<code>fwrite()</code>可以配合使用。在程序终止之前，使用<code>fwrite()</code>将数据保存进文件，下次运行时再用<code>fread()</code>将数据还原进入内存。</p><p>下面是读取上一节生成的二进制文件<code>output.bin</code>的例子。</p><pre class="hljs"><code><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> {
  FILE* fp;
  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c;

  fp = fopen(<span class="hljs-string">&quot;output.bin&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>);
  <span class="hljs-keyword">while</span> (fread(&amp;c, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">1</span>, fp) &gt; <span class="hljs-number">0</span>)
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre><p>运行后，得到如下结果。</p><pre class="hljs"><code><span class="hljs-number">5</span>
<span class="hljs-number">37</span>
<span class="hljs-number">0</span>
<span class="hljs-number">88</span>
<span class="hljs-number">255</span>
<span class="hljs-number">12</span>
</code></pre><h2 id="feof">feof() <a class="markdownIt-Anchor" href="#feof">#</a></h2><p><code>feof()</code>函数判断文件的内部指针是否指向文件结尾。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">feof</span><span class="hljs-params">(FILE *fp)</span>;
</code></pre><p><code>feof()</code>接受一个文件指针作为参数。如果已经到达文件结尾，会返回一个非零值（表示 true），否则返回<code>0</code>（表示 false）。</p><p>诸如<code>fgetc()</code>这样的文件读取函数，如果返回 EOF，有两种可能，一种可能是已读取到文件结尾，另一种可能是出现读取错误。<code>feof()</code>可以用来判断到底是那一种情况。</p><p>下面是通过<code>feof()</code>判断是否到达文件结尾，从而循环读取整个文件的例子。</p><pre class="hljs"><code><span class="hljs-type">int</span> num;
<span class="hljs-type">char</span> name[<span class="hljs-number">50</span>];

FILE* cfPtr = fopen(<span class="hljs-string">&quot;clients.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);

<span class="hljs-keyword">while</span> (!feof(cfPtr)) {
  <span class="hljs-built_in">fscanf</span>(cfPtr, <span class="hljs-string">&quot;%d%s\n&quot;</span>, &amp;num, name);
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s\n&quot;</span>, num, name);
}

fclose(cfPtr);
</code></pre><p>上面示例通过循环判断<code>feof()</code>是否读到文件结尾，从而实现读出整个文件内容。</p><p><code>feof()</code>为真时，可以通过<code>fseek()</code>、<code>rewind()</code>、<code>fsetpos()</code>函数改变文件内部读写位置的指示器，从而清除这个函数的状态。</p><h2 id="fseek">fseek() <a class="markdownIt-Anchor" href="#fseek">#</a></h2><p>每个文件指针都有一个内部指示器（内部指针），记录当前打开的文件的读写位置（file position），即下一次读写从哪里开始。文件操作函数（比如<code>getc()</code>、<code>fgets()</code>、<code>fscanf()</code>和<code>fread()</code>等）都从这个指示器指定的位置开始按顺序读写文件。</p><p>如果希望改变这个指示器，将它移到文件的指定位置，可以使用<code>fseek()</code>函数。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fseek</span><span class="hljs-params">(FILE* stream, <span class="hljs-type">long</span> <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> whence)</span>;
</code></pre><p><code>fseek()</code>接受3个参数。</p><ul><li><code>stream</code>：文件指针。</li><li><code>offset</code>：距离基准（第三个参数）的字节数。类型为 long int，可以为正值（向文件末尾移动）、负值（向文件开始处移动）或 0（保持不动）。</li><li><code>whence</code>：位置基准，用来确定计算起点。它的值是以下三个宏（定义在<code>stdio.h</code>）：<code>SEEK_SET</code>（文件开始处）、<code>SEEK_CUR</code>（内部指针的当前位置）、<code>SEEK_END</code>（文件末尾）</li></ul><p>请看下面的例子。</p><pre class="hljs"><code><span class="hljs-comment">// 定位到文件开始处</span>
fseek(fp, <span class="hljs-number">0L</span>, SEEK_SET);

<span class="hljs-comment">// 定位到文件末尾</span>
fseek(fp, <span class="hljs-number">0L</span>, SEEK_END);

<span class="hljs-comment">// 从当前位置后移2个字节</span>
fseek(fp, <span class="hljs-number">2L</span>, SEEK_CUR);

<span class="hljs-comment">// 定位到文件第10个字节</span>
fseek(fp, <span class="hljs-number">10L</span>, SEEK_SET);

<span class="hljs-comment">// 定位到文件倒数第10个字节</span>
fseek(fp, <span class="hljs-number">-10L</span>, SEEK_END);
</code></pre><p>上面示例中，<code>fseek()</code>的第二个参数为 long 类型，所以移动距离必须加上后缀<code>L</code>，将其转为 long 类型。</p><p>下面的示例逆向输出文件的所有字节。</p><pre class="hljs"><code><span class="hljs-keyword">for</span> (count = <span class="hljs-number">1L</span>; count &lt;= size; count++) {
  fseek(fp, -count, SEEK_END);
  ch = getc(fp);
}
</code></pre><p>注意，<code>fseek()</code>最好只用来操作二进制文件，不要用来读取文本文件。因为文本文件的字符有不同的编码，某个位置的准确字节位置不容易确定。</p><p>正常情况下，<code>fseek()</code>的返回值为0。如果发生错误（如移动的距离超出文件的范围），返回值为非零值（比如<code>-1</code>)。</p><h2 id="ftell">ftell() <a class="markdownIt-Anchor" href="#ftell">#</a></h2><p><code>ftell()</code>函数返回文件内部指示器的当前位置。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ftell</span><span class="hljs-params">(FILE* stream)</span>;
</code></pre><p>它接受一个文件指针作为参数。返回值是一个 long 类型的整数，表示内部指示器的当前位置，即文件开始处到当前位置的字节数，<code>0</code>表示文件开始处。如果发生错误，<code>ftell()</code>返回<code>-1L</code>。</p><p><code>ftell()</code>可以跟<code>fseek()</code>配合使用，先记录内部指针的位置，一系列操作过后，再用<code>fseek()</code>返回原来的位置。</p><pre class="hljs"><code><span class="hljs-type">long</span> file_pos = ftell(fp);

<span class="hljs-comment">// 一系列文件操作之后</span>
fseek(fp, file_pos, SEEK_SET);
</code></pre><p>下面的例子先将指示器定位到文件结尾，然后得到文件开始处到结尾的字节数。</p><pre class="hljs"><code>fseek(fp, <span class="hljs-number">0L</span>, SEEK_END);
size = ftell(fp);
</code></pre><h2 id="rewind">rewind() <a class="markdownIt-Anchor" href="#rewind">#</a></h2><p><code>rewind()</code>函数可以让文件的内部指示器回到文件开始处。它的原型定义在<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">(file* stream)</span>;
</code></pre><p>它接受一个文件指针作为参数。</p><p><code>rewind(fp)</code>基本等价于<code>fseek(fp, 0l, seek_set)</code>，唯一的区别是<code>rewind()</code>没有返回值，而且会清除当前文件的错误指示器。</p><h2 id="fgetposfsetpos">fgetpos()，fsetpos() <a class="markdownIt-Anchor" href="#fgetposfsetpos">#</a></h2><p><code>fseek()</code>和<code>ftell()</code>有一个潜在的问题，那就是它们都把文件大小限制在 long int 类型能表示的范围内。这看起来相当大，但是在32位计算机上，long int 的长度为4个字节，能够表示的范围最大为 4GB。随着存储设备的容量迅猛增长，文件也越来越大，往往会超出这个范围。鉴于此，C 语言新增了两个处理大文件的新定位函数：<code>fgetpos()</code>和<code>fsetpos()</code>。</p><p>它们的原型都定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">fgetpos</span><span class="hljs-params">(FILE* stream, <span class="hljs-type">fpos_t</span>* pos)</span>;
<span class="hljs-type">int</span> <span class="hljs-title function_">fsetpos</span><span class="hljs-params">(FILE* stream, <span class="hljs-type">const</span> <span class="hljs-type">fpos_t</span>* pos)</span>;
</code></pre><p><code>fgetpos()</code>函数会将文件内部指示器的当前位置，存储在指针变量<code>pos</code>。该函数接受两个参数，第一个是文件指针，第二个存储指示器位置的变量。</p><p><code>fsetpos()</code>函数会将文件内部指示器的位置，移动到指针变量<code>pos</code>指定的地址。注意，变量<code>pos</code>必须是通过调用<code>fgetpos()</code>方法获得的。<code>fsetpos()</code>的两个参数与<code>fgetpos()</code>必须是一样的。</p><p>记录文件内部指示器位置的指针变量<code>pos</code>，类型为<code>fpos_t*</code>（file position type 的缩写，意为文件定位类型）。它不一定是整数，也可能是一个 Struct 结构。</p><p>下面是用法示例。</p><pre class="hljs"><code><span class="hljs-type">fpos_t</span> file_pos;
fgetpos(fp, &amp;file_pos);

<span class="hljs-comment">// 一系列文件操作之后</span>
fsetpos(fp, &amp;file_pos);
</code></pre><p>上面示例中，先用<code>fgetpos()</code>获取内部指针的位置，后面再用<code>fsetpos()</code>恢复指针的位置。</p><p>执行成功时，<code>fgetpos()</code>和<code>fsetpos()</code>都会返回<code>0</code>，否则返回非零值。</p><h2 id="ferrorclearerr">ferror()，clearerr() <a class="markdownIt-Anchor" href="#ferrorclearerr">#</a></h2><p>所有的文件操作函数如果执行失败，都会在文件指针里面记录错误状态。后面的操作只要读取错误指示器，就知道前面的操作出错了。</p><p><code>ferror()</code>函数用来返回错误指示器的状态。可以通过这个函数，判断前面的文件操作是否成功。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">ferror</span><span class="hljs-params">(FILE *stream)</span>;
</code></pre><p>它接受一个文件指针作为参数。如果前面的操作出现错误，<code>ferror()</code>就会返回一个非零整数（表示 true），否则返回<code>0</code>。</p><p><code>clearerr()</code>函数用来重置出错指示器。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">void</span> <span class="hljs-title function_">clearerr</span><span class="hljs-params">(FILE* fp)</span>;
</code></pre><p>它接受一个文件指针作为参数，没有返回值。</p><p>下面是一个例子。</p><pre class="hljs"><code>FILE* fp = fopen(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);
<span class="hljs-type">char</span> c = fgetc(fp);

<span class="hljs-keyword">if</span> (ferror(fp)) {
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);
}

clearerr(fp);
</code></pre><p>上面示例中，<code>fgetc()</code>尝试读取一个以”写模式“打开的文件，读取失败就会返回 EOF。这时调用<code>ferror()</code>就可以知道上一步操作出错了。处理完以后，再用<code>clearerr()</code>清除出错状态。</p><p>文件操作函数如果正常执行，<code>ferror()</code>和<code>feof()</code>都会返回零。如果执行不正常，就要判断到底是哪里出了问题。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%d&quot;</span>, &amp;n) != <span class="hljs-number">1</span>) {
  <span class="hljs-keyword">if</span> (ferror(fp)) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;io error\n&quot;</span>);
  }
  <span class="hljs-keyword">if</span> (feof(fp)) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end of file\n&quot;</span>);
  }

  clearerr(fp);

  fclose(fp);
}
</code></pre><p>上面示例中，当<code>fscanf()</code>函数报错时，通过检查<code>ferror()</code>和<code>feof()</code>，确定到底发生什么问题。这两个指示器改变状态后，会保持不变，所以要用<code>clearerr()</code>清除它们，<code>clearerr()</code>可以同时清除两个指示器。</p><h2 id="remove">remove() <a class="markdownIt-Anchor" href="#remove">#</a></h2><p><code>remove()</code>函数用于删除指定文件。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename)</span>;
</code></pre><p>它接受文件名作为参数。如果删除成功，<code>remove()</code>返回<code>0</code>，否则返回非零值。</p><pre class="hljs"><code>remove(<span class="hljs-string">&quot;foo.txt&quot;</span>);
</code></pre><p>上面示例删除了<code>foo.txt</code>文件。</p><p>注意，删除文件必须是在文件关闭的状态下。如果是用<code>fopen()</code>打开的文件，必须先用<code>fclose()</code>关闭后再删除。</p><h2 id="rename">rename() <a class="markdownIt-Anchor" href="#rename">#</a></h2><p><code>rename()</code>函数用于文件改名，也用于移动文件。它的原型定义在头文件<code>stdio.h</code>。</p><pre class="hljs"><code><span class="hljs-type">int</span> <span class="hljs-title function_">rename</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* old_filename, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* new_filename)</span>;
</code></pre><p>它接受两个参数，第一个参数是现在的文件名，第二个参数是新的文件名。如果改名成功，<code>rename()</code>返回<code>0</code>，否则返回非零值。</p><pre class="hljs"><code>rename(<span class="hljs-string">&quot;foo.txt&quot;</span>, <span class="hljs-string">&quot;bar.txt&quot;</span>);
</code></pre><p>上面示例将<code>foo.txt</code>改名为<code>bar.txt</code>。</p><p>注意，改名后的文件不能与现有文件同名。另外，如果要改名的文件已经打开了，必须先关闭，然后再改名，对打开的文件进行改名会失败。</p><p>下面是移动文件的例子。</p><pre class="hljs"><code>rename(<span class="hljs-string">&quot;/tmp/evidence.txt&quot;</span>, <span class="hljs-string">&quot;/home/beej/nothing.txt&quot;</span>);
</code></pre></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="io.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> I/O 函数</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="specifier.html">变量说明符 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> C 语言教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="syntax.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本语法</span></a></li><li><a href="variable.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">变量</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">运算符</span></a></li><li><a href="flow-control.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">流程控制</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数据类型</span></a></li><li><a href="pointer.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">指针</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="string.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">字符串</span></a></li><li><a href="memory.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">内存管理</span></a></li><li><a href="struct.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">struct 结构</span></a></li><li><a href="typedef.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">typedef 命令</span></a></li><li><a href="union.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Union 结构</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="preprocessor.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">预处理器</span></a></li><li><a href="io.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">I/O 函数</span></a></li><li><a href="file.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">文件操作</span></a></li><li><a href="specifier.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">变量说明符</span></a></li><li><a href="multifile.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">多文件项目</span></a></li><li><a href="cli.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">命令行环境</span></a></li><li><a href="multibyte.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">多字节字符</span></a></li><li><a href="lib/index.html"><span class="icon"><i class="fa fa-caret-down"></i> </span><i class="fa folder fa-folder-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">标准库</span></a><ul><li><a href="lib/assert.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">assert.h</span></a></li><li><a href="lib/ctype.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">ctype.h</span></a></li><li><a href="lib/errno.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">errno.h</span></a></li><li><a href="lib/float.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">float.h</span></a></li><li><a href="lib/inttypes.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">inttypes.h</span></a></li><li><a href="lib/iso646.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">iso646.h</span></a></li><li><a href="lib/limits.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">limits.h</span></a></li><li><a href="lib/locale.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">locale.h</span></a></li><li><a href="lib/math.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">math.h</span></a></li><li><a href="lib/signal.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">signal.h</span></a></li><li><a href="lib/stdint.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">stdint.h</span></a></li><li><a href="lib/stdlib.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">stdlib.h</span></a></li><li><a href="lib/stdio.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">stdio.h</span></a></li><li><a href="lib/string.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">string.h</span></a></li><li><a href="lib/time.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">time.h</span></a></li><li><a href="lib/wchar.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">wchar.h</span></a></li><li><a href="lib/wctype.h.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">wctype.h</span></a></li></ul></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/clang-tutorial/master/docs/file.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/clang-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/clang-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"file.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88">文件指针</a></li>\n<li><a href="#fopen">fopen()</a></li>\n<li><a href="#%E6%A0%87%E5%87%86%E6%B5%81">标准流</a></li>\n<li><a href="#fclose">fclose()</a></li>\n<li><a href="#eof">EOF</a></li>\n<li><a href="#freopen">freopen()</a></li>\n<li><a href="#fgetcgetc">fgetc()，getc()</a></li>\n<li><a href="#fputcputc">fputc()，putc()</a></li>\n<li><a href="#fprintf">fprintf()</a></li>\n<li><a href="#fscanf">fscanf()</a></li>\n<li><a href="#fgets">fgets()</a></li>\n<li><a href="#fputs">fputs()</a></li>\n<li><a href="#fwrite">fwrite()</a></li>\n<li><a href="#fread">fread()</a></li>\n<li><a href="#feof">feof()</a></li>\n<li><a href="#fseek">fseek()</a></li>\n<li><a href="#ftell">ftell()</a></li>\n<li><a href="#rewind">rewind()</a></li>\n<li><a href="#fgetposfsetpos">fgetpos()，fsetpos()</a></li>\n<li><a href="#ferrorclearerr">ferror()，clearerr()</a></li>\n<li><a href="#remove">remove()</a></li>\n<li><a href="#rename">rename()</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-clang.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《文件操作》，出自网道（WangDoc.com）的《C 语言教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>