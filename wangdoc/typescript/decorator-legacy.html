<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>装饰器（旧语法） - TypeScript 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="装饰器（旧语法）"><link rel="apple-touch-icon" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/typescript-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/typescript-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;TypeScript 教程</a></li><li class="is-active"><a class="has-text-grey" href="decorator-legacy.html">装饰器（旧语法）</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="decorator.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 装饰器</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="declare.html">declare 关键字 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">装饰器（旧语法）</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><p>上一章介绍了装饰器的标准语法，那是在2022年通过成为标准的。但是在此之前，TypeScript 早在2014年就支持装饰器，不过使用的是旧语法。</p><p>装饰器的旧语法与标准语法，有相当大的差异。旧语法以后会被淘汰，但是目前大量现有项目依然在使用它，本章就介绍旧语法下的装饰器。</p><h2 id="experimentaldecorators-编译选项">experimentalDecorators 编译选项 <a class="markdownIt-Anchor" href="#experimentaldecorators-编译选项">#</a></h2><p>使用装饰器的旧语法，需要打开<code>--experimentalDecorators</code>编译选项。</p><pre class="hljs"><code>$ tsc --target ES5 --experimentalDecorators
</code></pre><p>此外，还有另外一个编译选项<code>--emitDecoratorMetadata</code>，用来产生一些装饰器的元数据，供其他工具或某些模块（比如 reflect-metadata ）使用。</p><p>这两个编译选项可以在命令行设置，也可以在<code>tsconfig.json</code>文件里面进行设置。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;ES6&quot;</span>,
    <span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h2 id="装饰器的种类">装饰器的种类 <a class="markdownIt-Anchor" href="#装饰器的种类">#</a></h2><p>按照所装饰的不同对象，装饰器可以分成五类。</p><blockquote><ul><li>类装饰器（Class Decorators）：用于类。</li><li>属性装饰器（Property Decorators）：用于属性。</li><li>方法装饰器（Method Decorators）：用于方法。</li><li>存取器装饰器（Accessor Decorators）：用于类的 set 或 get 方法。</li><li>参数装饰器（Parameter Decorators）：用于方法的参数。</li></ul></blockquote><p>下面是这五种装饰器一起使用的一个示例。</p><pre class="hljs"><code><span class="hljs-meta">@ClassDecorator</span>() <span class="hljs-comment">// （A）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {

  <span class="hljs-meta">@PropertyDecorator</span>() <span class="hljs-comment">// （B）</span>
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@MethodDecorator</span>() <span class="hljs-comment">//（C）</span>
  <span class="hljs-title function_">fly</span>(<span class="hljs-params">
    <span class="hljs-meta">@ParameterDecorator</span>() <span class="hljs-comment">// （D）</span>
    meters: <span class="hljs-built_in">number</span>
  </span>) {
    <span class="hljs-comment">// code</span>
  }

  <span class="hljs-meta">@AccessorDecorator</span>() <span class="hljs-comment">// （E）</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">egg</span>() {
    <span class="hljs-comment">// code</span>
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">egg</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// code</span>
  }
}
</code></pre><p>上面示例中，A 是类装饰器，B 是属性装饰器，C 是方法装饰器，D 是参数装饰器，E 是存取器装饰器。</p><p>注意，构造方法没有方法装饰器，只有参数装饰器。类装饰器其实就是在装饰构造方法。</p><p>另外，装饰器只能用于类，要么应用于类的整体，要么应用于类的内部成员，不能用于独立的函数。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">Decorator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;In Decorator&#x27;</span>);
}

<span class="hljs-meta">@Decorator</span> <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">decorated</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;in decorated&#x27;</span>);
}
</code></pre><p>上面示例中，装饰器用于一个普通函数，这是无效的，结果报错。</p><h2 id="类装饰器">类装饰器 <a class="markdownIt-Anchor" href="#类装饰器">#</a></h2><p>类装饰器应用于类（class），但实际上是应用于类的构造方法。</p><p>类装饰器有唯一参数，就是构造方法，可以在装饰器内部，对构造方法进行各种改造。如果类装饰器有返回值，就会替换掉原来的构造方法。</p><p>类装饰器的类型定义如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassDecorator</span> = &lt;<span class="hljs-title class_">TFunction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt;
  <span class="hljs-function">(<span class="hljs-params">target: TFunction</span>) =&gt;</span> <span class="hljs-title class_">TFunction</span> | <span class="hljs-built_in">void</span>;
</code></pre><p>上面定义中，类型参数<code>TFunction</code>必须是函数，实际上就是构造方法。类装饰器的返回值，要么是返回处理后的原始构造方法，要么返回一个新的构造方法。</p><p>下面就是一个示例。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">target:<span class="hljs-built_in">any</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;apply decorator&#x27;</span>)
  <span class="hljs-keyword">return</span> target;
}

<span class="hljs-meta">@f</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
<span class="hljs-comment">// 输出：apply decorator</span>
</code></pre><p>上面示例中，使用了装饰器<code>@f</code>，因此类<code>A</code>的构造方法会自动传入<code>f</code>。</p><p>类<code>A</code>不需要新建实例，装饰器也会执行。装饰器会在代码加载阶段执行，而不是在运行时执行，而且只会执行一次。</p><p>由于 TypeScript 存在编译阶段，所以装饰器对类的行为的改变，实际上发生在编译阶段。这意味着，TypeScript 装饰器能在编译阶段运行代码，也就是说，它本质就是编译时执行的函数。</p><p>下面再看一个示例。</p><pre class="hljs"><code><span class="hljs-meta">@sealed</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BugReport</span> {
  <span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;report&quot;</span>;
  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>;
 
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">t:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = t;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sealed</span>(<span class="hljs-params">constructor: <span class="hljs-built_in">Function</span></span>) {
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(constructor);
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
}
</code></pre><p>上面示例中，装饰器<code>@sealed()</code>会锁定<code>BugReport</code>这个类，使得它无法新增或删除静态成员和实例成员。</p><p>如果除了构造方法，类装饰器还需要其他参数，可以采取“工厂模式”，即把装饰器写在一个函数里面，该函数可以接受其他参数，执行后返回装饰器。但是，这样就需要调用装饰器的时候，先执行一次工厂函数。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">factory</span>(<span class="hljs-params">info:<span class="hljs-built_in">string</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;received: &#x27;</span>, info);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target:<span class="hljs-built_in">any</span></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;apply decorator&#x27;</span>);
    <span class="hljs-keyword">return</span> target;
  }
}

<span class="hljs-meta">@factory</span>(<span class="hljs-string">&#x27;log something&#x27;</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
</code></pre><p>上面示例中，函数<code>factory()</code>的返回值才是装饰器，所以加载装饰器的时候，要先执行一次<code>@factory('log something')</code>，才能得到装饰器。这样做的好处是，可以加入额外的参数，本例是参数<code>info</code>。</p><p>总之，<code>@</code>后面要么是一个函数名，要么是函数表达式，甚至可以写出下面这样的代码。</p><pre class="hljs"><code>@(<span class="hljs-function">(<span class="hljs-params">constructor: <span class="hljs-built_in">Function</span></span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;log something&#x27;</span>);
})
<span class="hljs-keyword">class</span> <span class="hljs-title class_">InlineDecoratorExample</span> {
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，<code>@</code>后面是一个箭头函数，这也是合法的。</p><p>类装饰器可以没有返回值，如果有返回值，就会替代所装饰的类的构造函数。由于 JavaScript 的类等同于构造函数的语法糖，所以装饰器通常返回一个新的类，对原有的类进行修改或扩展。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">target:<span class="hljs-built_in">any</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> target {
    value = <span class="hljs-number">123</span>;  
  };
}

<span class="hljs-meta">@decorator</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
  value = <span class="hljs-number">456</span>;
}

<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">value</span>); <span class="hljs-comment">// 123</span>
</code></pre><p>上面示例中，装饰器<code>decorator</code>返回一个新的类，替代了原来的类。</p><p>上例的装饰器参数<code>target</code>类型是<code>any</code>，可以改成构造方法，这样就更准确了。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Constructor</span> = {
  <span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): {}
};

<span class="hljs-keyword">function</span> decorator&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Constructor</span>&gt; (
  <span class="hljs-attr">target</span>: T
) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> target {
    value = <span class="hljs-number">123</span>;  
  };
}
</code></pre><p>这时，装饰器的行为就是下面这样。</p><pre class="hljs"><code>@decorator
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
A = <span class="hljs-title function_">decorator</span>(A) || A;
</code></pre><p>上面代码中，装饰器要么返回一个新的类<code>A</code>，要么不返回任何值，<code>A</code>保持装饰器处理后的状态。</p><h2 id="方法装饰器">方法装饰器 <a class="markdownIt-Anchor" href="#方法装饰器">#</a></h2><p>方法装饰器用来装饰类的方法，它的类型定义如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MethodDecorator</span> = &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">
  target: <span class="hljs-built_in">Object</span>,
  propertyKey: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">symbol</span>,
  descriptor: TypedPropertyDescriptor&lt;T&gt;
</span>) =&gt;</span> <span class="hljs-title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="hljs-built_in">void</span>;
</code></pre><p>方法装饰器一共可以接受三个参数。</p><ul><li>target：（对于类的静态方法）类的构造函数，或者（对于类的实例方法）类的原型。</li><li>propertyKey：所装饰方法的方法名，类型为<code>string|symbol</code>。</li><li>descriptor：所装饰方法的描述对象。</li></ul><p>方法装饰器的返回值（如果有的话），就是修改后的该方法的描述对象，可以覆盖原始方法的描述对象。</p><p>下面是一个示例。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">enumerable</span>(<span class="hljs-params">value: <span class="hljs-built_in">boolean</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">
    target: <span class="hljs-built_in">any</span>,
    propertyKey: <span class="hljs-built_in">string</span>,
    descriptor: PropertyDescriptor
  </span>) {
    descriptor.<span class="hljs-property">enumerable</span> = value;
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> {
  <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;
  }
 
  <span class="hljs-meta">@enumerable</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;
  }
}
</code></pre><p>上面示例中，方法装饰器<code>@enumerable()</code>装饰 Greeter 类的<code>greet()</code>方法，作用是修改该方法的描述对象的可遍历性属性<code>enumerable</code>。<code>@enumerable(false)</code>表示将该方法修改成不可遍历。</p><p>下面再看一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">
  target: <span class="hljs-built_in">any</span>,
  propertyKey: <span class="hljs-built_in">string</span>,
  descriptor: PropertyDescriptor
</span>) {
  <span class="hljs-keyword">const</span> original = descriptor.<span class="hljs-property">value</span>;

  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;params: &#x27;</span>, ...args);
    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;result: &#x27;</span>, result);
    <span class="hljs-keyword">return</span> result;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-meta">@logger</span>
  <span class="hljs-title function_">add</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span> </span>) {
    <span class="hljs-keyword">return</span> x + y;
  }
}

(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>()).<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-comment">// params:  1 2</span>
<span class="hljs-comment">// result:  3</span>
</code></pre><p>上面示例中，方法装饰器<code>@logger</code>用来装饰<code>add()</code>方法，它的作用是让该方法输出日志。每当<code>add()</code>调用一次，控制台就会打印出参数和运行结果。</p><h2 id="属性装饰器">属性装饰器 <a class="markdownIt-Anchor" href="#属性装饰器">#</a></h2><p>属性装饰器用来装饰属性，类型定义如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">PropertyDecorator</span> =
  <span class="hljs-function">(<span class="hljs-params">
    target: <span class="hljs-built_in">Object</span>,
    propertyKey: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">symbol</span>
  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;
</code></pre><p>属性装饰器函数接受两个参数。</p><ul><li>target：（对于实例属性）类的原型对象（prototype），或者（对于静态属性）类的构造函数。</li><li>propertyKey：所装饰属性的属性名，注意类型有可能是字符串，也有可能是 Symbol 值。</li></ul><p>属性装饰器不需要返回值，如果有的话，也会被忽略。</p><p>下面是一个示例。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">ValidRange</span>(<span class="hljs-params">min:<span class="hljs-built_in">number</span>, max:<span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target:<span class="hljs-built_in">Object</span>, key:<span class="hljs-built_in">string</span></span>) =&gt;</span> {
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, key, {
      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">v:<span class="hljs-built_in">number</span></span>) {
        <span class="hljs-keyword">if</span> (v &lt; min || v &gt; max) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Not allowed value <span class="hljs-subst">${v}</span>`</span>);
        }
      }
    });
  }
}

<span class="hljs-comment">// 输出 Installing ValidRange on year</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> {
  <span class="hljs-meta">@ValidRange</span>(<span class="hljs-number">1920</span>, <span class="hljs-number">2020</span>)
  year!: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> stud = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();

<span class="hljs-comment">// 报错 Not allowed value 2022 </span>
stud.<span class="hljs-property">year</span> = <span class="hljs-number">2022</span>;
</code></pre><p>上面示例中，装饰器<code>ValidRange</code>对属性<code>year</code>设立了一个上下限检查器，只要该属性赋值时，超过了上下限，就会报错。</p><p>注意，属性装饰器的第一个参数，对于实例属性是类的原型对象，而不是实例对象（即不是<code>this</code>对象）。这是因为装饰器执行时，类还没有新建实例，所以实例对象不存在。</p><p>由于拿不到<code>this</code>，所以属性装饰器无法获得实例属性的值。这也是它没有在参数里面提供属性描述对象的原因。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">logProperty</span>(<span class="hljs-params">target: <span class="hljs-built_in">Object</span>, member: <span class="hljs-built_in">string</span></span>) {
  <span class="hljs-keyword">const</span> prop = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(target, member);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Property <span class="hljs-subst">${member}</span> <span class="hljs-subst">${prop}</span>`</span>);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertyExample</span> {
  <span class="hljs-meta">@logProperty</span>
  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Foo&#x27;</span>;
}
<span class="hljs-comment">// 输出 Property name undefined</span>
</code></pre><p>上面示例中，属性装饰器<code>@logProperty</code>内部想要获取实例属性<code>name</code>的属性描述对象，结果拿到的是<code>undefined</code>。因为上例的<code>target</code>是类的原型对象，不是实例对象，所以拿不到<code>name</code>属性，也就是说<code>target.name</code>是不存在的，所以拿到的是<code>undefined</code>。只有通过<code>this.name</code>才能拿到<code>name</code>属性，但是这时<code>this</code>还不存在。</p><p>属性装饰器不仅无法获得实例属性的值，也不能初始化或修改实例属性，而且它的返回值也会被忽略。因此，它的作用很有限。</p><p>不过，如果属性装饰器设置了当前属性的存取器（getter/setter），然后在构造函数里面就可以对实例属性进行读写。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">Min</span>(<span class="hljs-params">limit:<span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">
    target: <span class="hljs-built_in">Object</span>,
    propertyKey: <span class="hljs-built_in">string</span>
  </span>) { 
    <span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>;

    <span class="hljs-keyword">const</span> getter = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> value;
    };

    <span class="hljs-keyword">const</span> setter = <span class="hljs-keyword">function</span>(<span class="hljs-params">newVal:<span class="hljs-built_in">string</span></span>) {
      <span class="hljs-keyword">if</span>(newVal.<span class="hljs-property">length</span> &lt; limit) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Your password should be bigger than <span class="hljs-subst">${limit}</span>`</span>);
      }
      <span class="hljs-keyword">else</span> {
        value = newVal;
      }      
    }; 
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, {
      <span class="hljs-attr">get</span>: getter,
      <span class="hljs-attr">set</span>: setter
    }); 
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;
  
  <span class="hljs-meta">@Min</span>(<span class="hljs-number">8</span>)
  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>;
  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">username: <span class="hljs-built_in">string</span>, password: <span class="hljs-built_in">string</span></span>){
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = username;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">password</span> = password;
  }    
}

<span class="hljs-keyword">const</span> u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;Foo&#x27;</span>, <span class="hljs-string">&#x27;pass&#x27;</span>); 
<span class="hljs-comment">// 报错 Your password should be bigger than 8 </span>
</code></pre><p>上面示例中，属性装饰器<code>@Min</code>通过设置存取器，拿到了实例属性的值。</p><h2 id="存取器装饰器">存取器装饰器 <a class="markdownIt-Anchor" href="#存取器装饰器">#</a></h2><p>存取器装饰器用来装饰类的存取器（accessor）。所谓“存取器”指的是某个属性的取值器（getter）和存值器（setter）。</p><p>存取器装饰器的类型定义，与方法装饰器一致。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AccessorDecorator</span> = &lt;T&gt;<span class="hljs-function">(<span class="hljs-params">
  target: <span class="hljs-built_in">Object</span>,
  propertyKey: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">symbol</span>,
  descriptor: TypedPropertyDescriptor&lt;T&gt;
</span>) =&gt;</span> <span class="hljs-title class_">TypedPropertyDescriptor</span>&lt;T&gt; | <span class="hljs-built_in">void</span>;
</code></pre><p>存取器装饰器有三个参数。</p><ul><li>target：（对于静态属性的存取器）类的构造函数，或者（对于实例属性的存取器）类的原型。</li><li>propertyKey：存取器的属性名。</li><li>descriptor：存取器的属性描述对象。</li></ul><p>存取器装饰器的返回值（如果有的话），会作为该属性新的描述对象。</p><p>下面是一个示例。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">configurable</span>(<span class="hljs-params">value: <span class="hljs-built_in">boolean</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">
    target: <span class="hljs-built_in">any</span>,
    propertyKey: <span class="hljs-built_in">string</span>,
    descriptor: PropertyDescriptor
  </span>) {
    descriptor.<span class="hljs-property">configurable</span> = value;
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">_x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">_y</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span> = x;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_y</span> = y;
  }
 
  <span class="hljs-meta">@configurable</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">x</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span>;
  }
 
  <span class="hljs-meta">@configurable</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">y</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_y</span>;
  }
}
</code></pre><p>上面示例中，装饰器<code>@configurable(false)</code>关闭了所装饰属性（<code>x</code>和<code>y</code>）的属性描述对象的<code>configurable</code>键（即关闭了属性的可配置性）。</p><p>下面的示例是将装饰器用来验证属性值，如果赋值不满足条件就报错。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">validator</span>(<span class="hljs-params">
  target: <span class="hljs-built_in">Object</span>,
  propertyKey: <span class="hljs-built_in">string</span>,
  descriptor: PropertyDescriptor
</span>){
  <span class="hljs-keyword">const</span> originalGet = descriptor.<span class="hljs-property">get</span>;
  <span class="hljs-keyword">const</span> originalSet = descriptor.<span class="hljs-property">set</span>;
  
  <span class="hljs-keyword">if</span> (originalSet) {
    descriptor.<span class="hljs-property">set</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) {
      <span class="hljs-keyword">if</span> (val &gt; <span class="hljs-number">100</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Invalid value for <span class="hljs-subst">${propertyKey}</span>`</span>);
      }
      originalSet.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, val);
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  #foo!: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@validator</span>
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">v</span>) {
    <span class="hljs-variable language_">this</span>.#foo = v;
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">foo</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#foo;
  }
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
c.<span class="hljs-property">foo</span> = <span class="hljs-number">150</span>;
<span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，装饰器用自己定义的存值器，取代了原来的存值器，加入了验证条件。</p><p>TypeScript 不允许对同一个属性的存取器（getter 和 setter）使用同一个装饰器，也就是说只能装饰两个存取器里面的一个，且必须是排在前面的那一个，否则报错。</p><pre class="hljs"><code><span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #<span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Decorator</span>
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">n:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.#name = n;
  }

  <span class="hljs-meta">@Decorator</span> <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;
  }
}
</code></pre><p>上面示例中，<code>@Decorator</code>同时装饰<code>name</code>属性的存值器和取值器，所以报错。</p><p>但是，下面的写法不会报错。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  #<span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>;

  <span class="hljs-meta">@Decorator</span>
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">n:<span class="hljs-built_in">string</span></span>) {
    <span class="hljs-variable language_">this</span>.#name = n;
  }
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;
  }
}
</code></pre><p>上面示例中，<code>@Decorator</code>只装饰它后面第一个出现的存值器（<code>set name()</code>），并不装饰取值器（<code>get name()</code>），所以不报错。</p><p>装饰器之所以不能同时用于同一个属性的存值器和取值器，原因是装饰器可以从属性描述对象上面，同时拿到取值器和存值器，因此只调用一次就够了。</p><h2 id="参数装饰器">参数装饰器 <a class="markdownIt-Anchor" href="#参数装饰器">#</a></h2><p>参数装饰器用来装饰构造方法或者其他方法的参数。它的类型定义如下。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">ParameterDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  target: <span class="hljs-built_in">Object</span>,
  propertyKey: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">symbol</span>,
  parameterIndex: <span class="hljs-built_in">number</span>
</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
</code></pre><p>参数装饰器接受三个参数。</p><ul><li>target：（对于静态方法）类的构造函数，或者（对于类的实例方法）类的原型对象。</li><li>propertyKey：所装饰的方法的名字，类型为<code>string|symbol</code>。</li><li>parameterIndex：当前参数在方法的参数序列的位置（从0开始）。</li></ul><p>该装饰器不需要返回值，如果有的话会被忽略。</p><p>下面是一个示例。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">
  target: <span class="hljs-built_in">Object</span>,
  propertyKey: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">symbol</span>,
  parameterIndex: <span class="hljs-built_in">number</span>
</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">String</span>(propertyKey)}</span> NO.<span class="hljs-subst">${parameterIndex}</span> Parameter`</span>);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-title function_">member</span>(<span class="hljs-params">
    <span class="hljs-meta">@log</span> x:<span class="hljs-built_in">number</span>,
    <span class="hljs-meta">@log</span> y:<span class="hljs-built_in">number</span>
  </span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`member Parameters: <span class="hljs-subst">${x}</span> <span class="hljs-subst">${y}</span>`</span>);
  }
}

<span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
c.<span class="hljs-title function_">member</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
<span class="hljs-comment">// member NO.1 Parameter</span>
<span class="hljs-comment">// member NO.0 Parameter </span>
<span class="hljs-comment">// member Parameters: 5 5 </span>
</code></pre><p>上面示例中，参数装饰器会输出参数的位置序号。注意，后面的参数会先输出。</p><p>跟其他装饰器不同，参数装饰器主要用于输出信息，没有办法修改类的行为。</p><h2 id="装饰器的执行顺序">装饰器的执行顺序 <a class="markdownIt-Anchor" href="#装饰器的执行顺序">#</a></h2><p>前面说过，装饰器只会执行一次，就是在代码解析时执行，哪怕根本没有调用类新建实例，也会执行，而且从此就不再执行了。</p><p>执行装饰器时，按照如下顺序执行。</p><ol><li>实例相关的装饰器。</li><li>静态相关的装饰器。</li><li>构造方法的参数装饰器。</li><li>类装饰器。</li></ol><p>请看下面的示例。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">key:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">any</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行：&#x27;</span>, key);
  };
}

<span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;类装饰器&#x27;</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;静态方法&#x27;</span>)
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) {}
  
  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;实例方法&#x27;</span>)
  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;构造方法参数&#x27;</span>) foo:<span class="hljs-built_in">any</span></span>) {}
}
</code></pre><p>加载上面的示例，输出如下。</p><pre class="hljs"><code>执行： 实例方法
执行： 静态方法
执行： 构造方法参数
执行： 类装饰器
</code></pre><p>同一级装饰器的执行顺序，是按照它们的代码顺序。但是，参数装饰器的执行总是早于方法装饰器。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">key:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">any</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行：&#x27;</span>, key);
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;方法1&#x27;</span>)
  <span class="hljs-title function_">m1</span>(<span class="hljs-params"><span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;参数1&#x27;</span>) foo:<span class="hljs-built_in">any</span></span>) {}

  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;属性1&#x27;</span>)
  <span class="hljs-attr">p1</span>: <span class="hljs-built_in">number</span>;

  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;方法2&#x27;</span>)
  <span class="hljs-title function_">m2</span>(<span class="hljs-params"><span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;参数2&#x27;</span>) foo:<span class="hljs-built_in">any</span></span>) {}

  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;属性2&#x27;</span>)
  <span class="hljs-attr">p2</span>: <span class="hljs-built_in">number</span>;
}
</code></pre><p>加载上面的示例，输出如下。</p><pre class="hljs"><code>执行： 参数<span class="hljs-number">1</span>
执行： 方法<span class="hljs-number">1</span>
执行： 属性<span class="hljs-number">1</span>
执行： 参数<span class="hljs-number">2</span>
执行： 方法<span class="hljs-number">2</span>
执行： 属性<span class="hljs-number">2</span>
</code></pre><p>上面示例中，实例装饰器的执行顺序，完全是按照代码顺序的。但是，同一个方法的参数装饰器，总是早于该方法的方法装饰器执行。</p><p>如果同一个方法或属性有多个装饰器，那么装饰器将顺序加载、逆序执行。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">key:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">any</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;加载：&#x27;</span>, key);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行：&#x27;</span>, key);
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;A&#x27;</span>)
  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;B&#x27;</span>)
  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;C&#x27;</span>)
  <span class="hljs-title function_">m1</span>(<span class="hljs-params"></span>) {}
}
<span class="hljs-comment">// 加载： A</span>
<span class="hljs-comment">// 加载： B</span>
<span class="hljs-comment">// 加载： C</span>
<span class="hljs-comment">// 执行： C</span>
<span class="hljs-comment">// 执行： B</span>
<span class="hljs-comment">// 执行： A</span>
</code></pre><p>如果同一个方法有多个参数，那么参数也是顺序加载、逆序执行。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">key:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">any</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;加载：&#x27;</span>, key);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行：&#x27;</span>, key);
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-title function_">method</span>(<span class="hljs-params">
    <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;A&#x27;</span>) a:<span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;B&#x27;</span>) b:<span class="hljs-built_in">any</span>,
    <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;C&#x27;</span>) c:<span class="hljs-built_in">any</span>,
  </span>) {}
}
<span class="hljs-comment">// 加载： A</span>
<span class="hljs-comment">// 加载： B</span>
<span class="hljs-comment">// 加载： C</span>
<span class="hljs-comment">// 执行： C</span>
<span class="hljs-comment">// 执行： B</span>
<span class="hljs-comment">// 执行： A</span>
</code></pre><h2 id="为什么装饰器不能用于函数">为什么装饰器不能用于函数？ <a class="markdownIt-Anchor" href="#为什么装饰器不能用于函数">#</a></h2><p>装饰器只能用于类和类的方法，不能用于函数，主要原因是存在函数提升。</p><p>JavaScript 的函数不管在代码的什么位置，都会提升到代码顶部。</p><pre class="hljs"><code><span class="hljs-title function_">addOne</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addOne</span>(<span class="hljs-params">n:<span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;
}
</code></pre><p>上面示例中，函数<code>addOne()</code>不会因为在定义之前执行而报错，原因就是函数存在提升，会自动提升到代码顶部。</p><p>如果允许装饰器可以用于普通函数，那么就有可能导致意想不到的情况。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;

<span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">target:<span class="hljs-built_in">any</span></span>) {
  counter++;
};

<span class="hljs-meta">@add</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">//...</span>
}
</code></pre><p>上面示例中，本来的意图是装饰器<code>@add</code>每使用一次，变量<code>counter</code>就加<code>1</code>，但是实际上会报错，因为函数提升的存在，使得实际执行的代码是下面这样。</p><pre class="hljs"><code>@add <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">//...</span>
}

<span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">target:any</span>) {
  counter++;
};
</code></pre><p>上面示例中，<code>@add</code>还没有定义就调用了，从而报错。</p><p>总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><p>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行，没必要写成装饰器。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">loggingDecorator</span>(<span class="hljs-params">wrapped</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Starting&#x27;</span>);
    <span class="hljs-keyword">const</span> result = wrapped.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Finished&#x27;</span>);
    <span class="hljs-keyword">return</span> result;
  }
}

<span class="hljs-keyword">const</span> wrapped = <span class="hljs-title function_">loggingDecorator</span>(doSomething);
</code></pre><p>上面示例中，<code>loggingDecorator()</code>是一个装饰器，只要把原始函数传入它执行，就能起到装饰器的效果。</p><h2 id="多个装饰器的合成">多个装饰器的合成 <a class="markdownIt-Anchor" href="#多个装饰器的合成">#</a></h2><p>多个装饰器可以应用于同一个目标对象，可以写在一行。</p><pre class="hljs"><code><span class="hljs-meta">@f</span> <span class="hljs-meta">@g</span> x
</code></pre><p>上面示例中，装饰器<code>@f</code>和<code>@g</code>同时装饰目标对象<code>x</code>。</p><p>多个装饰器也可以写成多行。</p><pre class="hljs"><code><span class="hljs-meta">@f</span>
<span class="hljs-meta">@g</span>
x
</code></pre><p>多个装饰器的效果，类似于函数的合成，按照从里到外的顺序执行。对于上例来说，就是执行<code>f(g(x))</code>。</p><p>前面也说过，如果<code>f</code>和<code>g</code>是表达式，那么需要先从外到里求值。</p><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="https://saul-mirone.github.io/a-complete-guide-to-typescript-decorator/" target="_blank" rel="noopener">A Complete Guide to TypeScript Decorators</a>, by Saul Mirone</li><li><a href="https://techsparx.com/nodejs/typescript/decorators/introduction.html" target="_blank" rel="noopener">Deep introduction to using and implementing TypeScript decorators</a>, by David Herron</li><li><a href="https://techsparx.com/nodejs/typescript/decorators/properties.html" target="_blank" rel="noopener">Deep introduction to property decorators in TypeScript</a>, by David Herron</li><li><a href="https://techsparx.com/nodejs/typescript/decorators/accessors.html" target="_blank" rel="noopener">Deep introduction to accessor decorators in TypeScript</a>, by David Herron</li><li><a href="https://dev.to/danywalls/using-property-decorators-in-typescript-with-a-real-example-44e" target="_blank" rel="noopener">Using Property Decorators in Typescript with a real example</a>, by Dany Paredes</li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="decorator.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 装饰器</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="declare.html">declare 关键字 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> TypeScript 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="intro.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">简介</span></a></li><li><a href="basic.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">基本用法</span></a></li><li><a href="any.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">any 类型</span></a></li><li><a href="types.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型系统</span></a></li><li><a href="array.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">数组</span></a></li><li><a href="tuple.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">元组</span></a></li><li><a href="symbol.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">symbol 类型</span></a></li><li><a href="function.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">函数</span></a></li><li><a href="object.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">对象</span></a></li><li><a href="interface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">interface</span></a></li><li><a href="class.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类</span></a></li><li><a href="generics.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">泛型</span></a></li><li><a href="enum.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Enum 类型</span></a></li><li><a href="assert.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型断言</span></a></li><li><a href="module.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">模块</span></a></li><li><a href="namespace.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">namespace</span></a></li><li><a href="decorator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器</span></a></li><li><a href="decorator-legacy.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">装饰器（旧语法）</span></a></li><li><a href="declare.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">declare 关键字</span></a></li><li><a href="d.ts.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">d.ts 类型声明文件</span></a></li><li><a href="operator.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型运算符</span></a></li><li><a href="mapping.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型映射</span></a></li><li><a href="utility.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">类型工具</span></a></li><li><a href="comment.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">注释指令</span></a></li><li><a href="tsconfig.json.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsconfig.json 文件</span></a></li><li><a href="tsc.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">tsc 命令</span></a></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/typescript-tutorial/main/docs/decorator-legacy.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/typescript-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8 is-6-widescreen is-offset-1-widescreen"><div id="disqus_thread"></div></div></div></div></section><footer class="footer"><div class="container"><div class="content has-text-centered"><p>联系：contact@wangdoc.com</p></div></div></footer><script>var LOPPO={current_path:"decorator-legacy.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#experimentaldecorators-%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9">experimentalDecorators 编译选项</a></li>\n<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB">装饰器的种类</a></li>\n<li><a href="#%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8">类装饰器</a></li>\n<li><a href="#%E6%96%B9%E6%B3%95%E8%A3%85%E9%A5%B0%E5%99%A8">方法装饰器</a></li>\n<li><a href="#%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8">属性装饰器</a></li>\n<li><a href="#%E5%AD%98%E5%8F%96%E5%99%A8%E8%A3%85%E9%A5%B0%E5%99%A8">存取器装饰器</a></li>\n<li><a href="#%E5%8F%82%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8">参数装饰器</a></li>\n<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">装饰器的执行顺序</a></li>\n<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A3%85%E9%A5%B0%E5%99%A8%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0">为什么装饰器不能用于函数？</a></li>\n<li><a href="#%E5%A4%9A%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%90%88%E6%88%90">多个装饰器的合成</a></li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-typescript.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《装饰器（旧语法）》，出自网道（WangDoc.com）的《TypeScript 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>